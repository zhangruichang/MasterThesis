\chapter{相关工作}
\rhead{相关工作}

由于图数据的基础性和其应用的广泛性，图数据上的查询研究被大家广泛关注。而可达性查询作为图数据查询中最基础的算法之一，它的研究更是受到了研究人员们的广泛兴趣。在本章节中，我们首先介绍关于图数据查询上目前一些比较流行的隐私保护研究。然后介绍当前一些比较成熟和优秀的图数据隐私保护查询的工作，最后我们再介绍当前在图数据可达性查询方面比较优秀的算法。

\section{图数据库上隐私保护方法概述}
%\label{sec:nokeyword}

图数据库一直是学术界和工业界广泛关注的最基本的数据结构，同时随着人们对隐私问题的关注度也越来越注重，关于图数据隐私保护方面的成果也是非常多。它们中的大部分都是通过一定的算法将图的结果进行匿名化或模糊化，例如\cite{k-isomorphism,k-degree,1-neighborhood,k-automorphism,bhagat2009class,zheleva2008preserving,das2010anonymizing}。 这些方法的主要思想为通过修改原始的图数据使得能够满足定义的安全性要求。
我们可以将目前比较先进的匿名化方法分为以下三类：
\begin{itemize}
\item 通过对图数据中边的信息进行修改的k-匿名隐私保护方法。在该方法中，通过对图中的一系列边的删除与添加，使得修改后的图中的每一个点都有k-1个点和其具有相同的结构模式。

\item 图数据边的随机化。在该类方法中，通过随机的添加、删除或者交换两条边使得攻击者无法通过基于概率的方法对原来的图数据结构进行猜测。

\item 基于聚类的泛化方法。在该类方法中，图中的顶点和边被聚集成不同的分组，然后将一个小的子图转化成一个点。通过此类方法，图中的每一个单独的点的信息被隐藏。
\end{itemize}
例如，在\cite{k-isomorphism} 文章中，作者通过将原图文件划分为$k$个不相交的同构子图，然后这样划分以后，虽然保护了隐私数据，但是基于划分的子图做可达性查询变成了一件几乎不可能完成的任务。在\cite{k-degree}文章中，作者指出现实世界里的图数据中顶点的度的信息是验证分布不均匀的，这使得攻击者很容易能够收集到一个目标顶点的度的信息。他们研究了如何通过添加或者删除一个图中的部分边来获得一个k-degree的匿名化图数据。在处理后的图数据中，每个顶点都至少拥有k-1个和它具有相同度数的顶点。 在该方法中，k-degree匿名化可以使得攻击则根据一些先验知识来对图中部分点的信息进行推测。虽然以上的三类方法能够有效的保护图数据的隐私信息，但是通过对图中顶点或者边的增减操作来实现图数据的模糊化，这些模糊化后的图数据改变了原图数据的特性，使得这些图数据不具有了与可达性查询相应的信息。目前，关于如何使用匿名图数据文件来完成指定的一些查询，在学术界和工业界都还没有这样的一些工作。


\section{图数据库查询验证}

查询验证是一个安全领域里的问题，通常在这里面，服务提供商\SP 被认为是不安全和不可信赖的\cite{auth_graph_wo_leaking,forest,cao2011privacy}。它要求客户端验证从服务器端返回的图数据的正确性和未被修改性。Kundu 等人在\cite{auth_graph_wo_leaking,forest}文章中，他们主要研究了如何在不泄露数据(可能是树、图或是森林) 任何额外的信息的情况下，验证用户可以从服务商获取到的部分数据(可能是原先数据的一个子图或者子树)的正确性，以防止服务商用一些非来自原始数据的虚假数据来欺骗用户。在他们的技术中，他们优化了验证数据的签名技术。在\cite{zhe}文章中，作者提出了一种基于外包的图数据系统框架上的高效子图查询验证算法。在文章中，作者通过使用相应的技术，对从服务商返回的查询结果进行验证，进而保证用户查询结果的正确性。在本文中，我们主要的研究问题是如何在基于外包图数据框架下图上可达性查询技术的研究，在我们的问题中，我们主要注重如何通过相应的算法和框架使得我们在不泄露原始图结构信息和查询结果的情况下，高效的完成图上点之间的可达性。

\section{基于隐私保护的图查询服务}

在\cite{edgeprivacy}文章中，作者分析了如何在保护图数据边信息的情况下，如何判断图上两点之间的可达性。但是他们的方法向服务商\SP 暴露的查询点和图数据的部分结构信息，无法做到真正的达到我们所定义的隐私保护级别。在\cite{Jeffery}文章中，作者提出了一种云计算环境下基于保护临近节点信息的最短距离查询算法。在他们的文章中，他们希望在基于外包的图数据条件下能够实现保护邻居节点的信息的情况下，同时能够维护邻居节点间的连接关系和图上任意两点间的最短路信息。但是如果我们直接将他们的工作应用到图上可达性查询，关于图数据的一些结构信息和查询点之间的可达性信息仍然将会暴露给服务商\SP .

在\cite{PIR+SP}文章中，作者使用了PIR(Private information retrieval，所谓PIR协议是指通过该协议可以使得用户从存储数据库中的服务器上检索一个条目，同时使得该服务器无法判断哪一个条目被用户检索过)\cite{PIR}使得可以在计算两个查询点之间最短路径时没有任何关于图数据信息的泄露。但是由于PIR具有众所周知的高昂的计算成本，并且使用PIR 方法对于每个查询，为了实现隐私保护，需要传输相同数量的文件大小，这个传输数据的大小是所有查询中最大的那个，那么数据传输成本也是非常昂贵。由于可达性查询是一个简单并且非常基础的查询，高昂的计算和传输代价使得PIR不适合用于可达性的隐私保护。在\cite{icdcs}文章中，作者提出了一种基于加密的图数据上的小图的子图查询算法。在该文中，作者的方法提供了查询的隐私保护、索引的隐私保护以及图文件的特征隐私保护等功能，但是如果将其方法考虑到可达性查询上，可达性查询无法将一个查询变为一个子图查询。在\cite{subgraph+count}文章中，作者提出了一种基于将图数据的部分统计信息外包给服务商\SP 以保护图数据边微分隐私保护的算法。虽然他们的算法支持很多的计数以及查询算法，但是对于可达性查询，该算法无法实现。

\section{可达性查询算法概述}

可达性查询作为图论中最基础的查询之一，一个图$G$上的可达性查询：查询顶点$u$是否可以到达顶点$v$。有两种最简单最直接的方法来处理这样一个可达性查询，第一个方法可以使用深度优先或者广度优先遍历方法从顶点$u$出发，看能否遍历到顶点$v$。使用这种搜索算法最坏的情况需要$O(n+m)$的时间复杂度，其中$n$和$m$分别表示图$G$的顶点数和边数。第二个方法，我们可以事先计算好图$G$的传递闭包，并将该传递闭包集合存储在硬盘上，在做查询时，只要检查元素$(u,v)$ 是否在传递闭包集合中。在这种情况下，它需要$O(n^2)$ 的存储开销。然而这两种最简单和最直接的方法都是不可行的，在前一种方法中它需要太长的查询时间，在第二种方法中需要太多的存储空间来保存传递闭包集合，尤其当图数据具有百万个以上节点时，这些方法几乎无法实现可达性查询。

在目前的数据库研究领域，研究工作者们提出了很多的算法来降低存储开销的同时保持高效的可达性查询。
正如前面介绍的一样，如果我们可以预先计算好图的传递闭包，我们可以用$O(n^2)$存储开销换来$O(1)$的查询时间，或者我们可以直接使用深度优先或者广度优先遍历算法，在不需要存储空间的情况下，可以在$O(n+m)$时间里回答一个可达性查询。目前的研究工作就是在这两种极端情况里找到一个平衡点，使得一个查询的查询时间在$O(1)$ 到$O(n+m)$ 之间，同时也可以需要较小的索引存储开销。例如，一些方法基于图$G$的生成树并再加上一些额外的信息来保存图$G$的可达性信息来构建图的可达性索引。在另一些方法中，通过对传递闭包的压缩来获得一个大小可以接受的索引。基于这个方向的努力，构建索引的时间开销也变成了一种重要的考虑指标。

\begin{table}[h]
\centering
\caption{各种主流的可达性索引时间和空间复杂度}
\begin{tabular}{p{5cm}p{2.5cm}p{3.5cm}p{2.5cm}}
\hline
索引方法 & 查询时间  & 索引创建时间 & 索引大小 \\
\hline
Transitive Closure\cite{simon1988improved} & $O(1)$ & $O(nm)$ & $O(n^2)$ \\
\hline
Tree+SSPI\cite{chen2005stack} & $O(m-n)$ & $O(n+m)$ & $O(n+m)$  \\
\hline
GRIPP\cite{trissl2007fast} &$O(m-n)$ & $O(n+m)$ & $O(n+m)$  \\
\hline
Dual-Labelng\cite{wang2006dual} &$O(m-n)$ & $O(n+m+t^3)$ & $O(n+t^2)$  \\
\hline
Tree Cover\cite{sigmod1989} &$O(\log(n))$ & $O(nm)$ & $O(n^2)$  \\
\hline
Chain Cover\cite{chen2008efficient} &$O(\log(k))$ & $O(n^2+kn\sqrt k)$ & $O(nk)$  \\
\hline
Path-tree Cover\cite{pathtree} &$O(\log ^2(k'))$ & $O(nm)$ & $O(nk')$  \\
\hline
2-hop Cover\cite{cohen} &$O(m^{1/2})$ & $O(n^3*|TC|)$ & $O(nm^{1/2})$  \\
\hline
3-hop Cover\cite{3hop} &$O(\log n+k)$ & $O(kn^2*|Con(G)|)$ & $O(nk)$  \\
\hline
\end{tabular}
\label{table:overview}
\end{table}

表~\ref{table:overview}给出了目前比较高效和流行的可达性查询索引的时间和空间复杂度。对于一个图$G=(V,E)$，其中$n=|V|$，$m=|E|$。在\cite{simon1988improved}中作者提出了一种计算图的传递闭包的算法，该算法可以在$O(nm)$内计算出一个图的传递闭包集合。换句话来说，计算一个基于传递闭包的可达性索引的时间复杂度为$O(nm)$，而在最坏的情况下该索引的空间大小为$O(n^2)$。基于该传递闭包索引，一个可达性查询的查询时间为常数时间$O(1)$。

在\cite{chen2005stack}中，作者基于图$G$的生成树提出了一种可达性索引方法。改索引构建算法的时间复杂度为$O(n+m)$，索引的空间大小为$O(n+m)$。给定图$G$中的两个顶点$u$和$v$，查询顶点$u$是否可以到达顶点$v$。如果图$G$的生成树里有一条从$u$到$v$的路径，那么该算法可以在$O(1)$时间里返回查询结果。对于如何快速判断生成树中是否存在这样一条路径，我们可以使用生成树上每一个顶点的编码通过一个简单的断言来实现，我们将该断言表示为$\p(,)$。 我们假设在生成树上顶点$u$和$v$的编码分别是$code(u)$和$code(v)$，如果$\p(code(u),code(v))$为真，那么顶点$u$ 可以到达顶点$v$。由于生成树中每个顶点的编码是根据生成树上顶点之间的链接关系来确定的，如果$\p(code(u),code(v))$为假并不代表顶点$u$不可以到达顶点$v$，因为图$G$有有一些其他的边并没有出现在生成树中。对于此种情况，作者使用了一个额外的数据结构，称之为SSPI(Surrogate and Surplus Predecessor Index)来在运行时来计算顶点之间的可达性信息。使用SSPI索引进行可达性查询在最坏的情况下时间复杂度为$O(m-n)$。我们称这种可达性索引方法为Tree+SSPI。和\cite{chen2005stack}中类似，在\cite{trissl2007fast}中，作者同样使用了一棵生成树来进行可达性的查询。在\cite{trissl2007fast}中，作者基于生成树建立了GRIPP(GRaph Indexing base on Pre- and Postorder numbering)索引。对于生成树上可以直接回答的可达性查询，可以在$O(1)$时间给出结果。对于生成树中无法确定的查询，作者给出了一些基于GRIPP索引的遍历策略。在GRIPP中，算法的时间复杂度和空间复杂度和Tree+SSPI一致。

在\cite{wang2006dual}中，作者发现现实世界中，大部分应用中的大图都比较稀疏，所以作者提出了一种针对稀疏大图的dual-labeling 索引方法。稀疏图意味着图$G$中没有出现在它的一个生成树中的边非常少。我们假设没有出现在生成树中的边的数目为$t$，很显然对于稀疏图$t<<n$，作者考虑为图中出现在生成树中的边简历一个树编码索引，对于图中未出现在生成树中的边，使用一种图编码的方式来建立索引，作者为图中未出现在生成树中的边计算它们的传递闭包集合。Dual-labeling可以实现$O(1)$的可达性查询时间复杂度，需要的索引大小为$O(n+t^2)$，索引的创建时间为$O(n+m+t^3)$。

在\cite{sigmod1989}中，作者研究了一种树覆盖(Tree Cover)的索引方法来对图中的顶点进行索引。简单来说，如果一个顶点$u$ 可以到达顶点$v$，那么顶点$u$可以到达以顶点$v$ 为根的子树上的任何点。文章中，作者提出了一种最优的树覆盖的方法来最大程序的压缩图的传递闭包元素。在最坏的情况下，该索引的空间大小为$O(n^2)$，然而在实际情况总，该索引方法通常比\cite{chen2008efficient}中的链覆盖方法具有更好的结果。Tree Cover索引方法对大图建立索引非常高效，它的索引创建时间复杂度为$O(nm)$，在Tree Cover索引上，可达性查询的时间复杂度为$O(\log n)$。

在\cite{jagadish1990compression}中，作者提出了一种链覆盖(Chain Cover)的索引方法。Chain Cover的主要思想是将一个图$G$分解成两两不相交的链。链的概念要比路径的概念更加普遍。考虑图$G$中的一条路径$a \rightarrow b \rightarrow c \rightarrow d$，其中$x \rightarrow y$表示图中的一条有向边。图中的一条路径可以被看成一条链，$a \to b \to c \to d$，其中$x \to y$表示顶点$x$可以到达顶点$y$。图中的一条路径可以被分解成两对不相交的链，例如$a \to c$和$b \to d$，这里$a \to c$和$b \to d$都不是一条路径。和Tree Cover中一样，如果顶点$u$可以到达顶点$v $，那么顶点$u$可以到达任何以顶点$v$作为起点的链上的所有顶点。在文中，作者提出了一种时间复杂度在$O(n^3)$的算法来找到一个图的最少数量的链覆盖。一个图$G$中找到的链的数量我们称之为图$G$的宽度，表示为$k$。基于Chain Cover，我们可以构建出一个大小为$O(nk)$的可达性索引，可达性查询的时间复杂度为$O(\log k)$。在\cite{chen2008efficient}中作者进一步提出了一种基于Chain Cover的优化索引方法，该索引创建时间复杂度可以降到$O(n^2+kn\sqrt k)$。

在\cite{pathtree}中作者延续Tree Cover中的思想，提出了一种path-tree cover的索引方法。作者通过将图$G$分解成很多互不相交的路径，然后将分解后得到的每一个路径作为树中的一个顶点，建立一个tree cover索引。我们假设图分解得到的互不相交的路径数记为$k'$，作者提出了两种算法构建可达性索引，分别称之为PTree-1和PTree-2。这两种算法构建的索引大小都为$O(nk')$。算法PTree-1构建可达性索引的时间复杂度为$O(nm)$，算法PTree-2的时间复杂度为$O(mk')$。 基于这两种算法得到的可达性索引的查询时间复杂度都为$O(\log ^2 k')$。

在\cite{cohen}中，作者提出了一种2-hop cover索引方法。对于图$G$中的每个顶点$u$都分配有两个集合($\lin(u)$和$\lout(u)$)，这两个集合作为该顶点的索引。集合$\lin(u)$ 中包含有一系列可以到达顶点$u$的顶点，集合$\lout(u)$中包含顶点$u$可以到达的顶点集合。每个顶点的索引保证如果在图$G$中，顶点$u$可以到达顶点$v$，则$\lout(u) \cap \lin(v) \neq \emptyset $。找到一个图的2-hop cover被证明是一个集合覆盖问题。在文章中，作者提出了一种近似方法可以得到$O(nm^{1/2})$大小的索引。该索引的时间复杂度还没有得到一个确定的值。在\cite{jin2008efficiently}中，作者给出了一个时间复杂度为$O(n^3*|TC|)$，其中$|TC|$为图$G$的传递闭包元素集合的大小。关于2-hop索引的构建方法我们将在第~\ref{sec:2hop}中详细介绍。在\cite{3hop}中，作者进一步提出了一种结合Chain Cover和2-hop的索引方法，我们称之为3-hop。3-hop索引算法的时间复杂度为$O(kn^2|Con(G)|)$，这里$k$是图$G$中分解得到的互不相交的路径的数目，$Con(G)$是文章中定义的关于传递闭包元素的一个参数。


以上为目前关于图数据上的可达性计算的一些典型的索引方法的介绍，总的来说，我们根据\cite{sigmod2012}文章中的分类，我们可以把目前比较流行的可达性查询算法分为基于传递闭包压缩的索引方法、对在线搜索优化的方法和基于hop的索引方法。

\paragraph{传递闭包压缩算法}

对于这一类可达性查询索引方法的主要思想是对给定图数据的传递闭包进行压缩减小索引对空间的需求，并且对图中的每个顶点都用一个可达的顶点集合进行编码。使用了这种方法进行索引以后，如果想要查询两个点$u$和$v$是否可达，我们仅仅需要查询顶点$u$ 的可达性集合里是否包含顶点$v$，如果包含则说明顶点$u$可以到达顶点$v$，反之则不可达。\cite{sigmod1989,pathtree,bitcompression}等文章是目前比较先进高效的基于传递闭包的压缩算法。使用传递闭包压缩算法，他们的查询效率一般是最高效的，然而，此类方法的索引存储开销通常是最大的，有时候甚至是不可能实现的。

\paragraph{优化的在线搜索算法}

这一类算法最基本的思想是利用在线搜索算法(如深度优先搜索算法DFS，广度优先搜索算法BFS)在线的计算两点之间的可达性。具体来说，他们首先利用一些额外的信息(例如通过后续拓扑遍历或者生成树)来对给定的查询进行搜索空间的剪枝。然后，再利用DFS 或BFS搜索算法结合标签信息来得到最后的答案信息。实践证明，\cite{ferrari,grail}等算法可以支持具有千万级别的图数据上的可达性查询。然而，通常这些在线搜索算法(DFS或BFS)在进行检索时都携带有图数据的结构信息。目前来看，还不知道如何使得在进行深度优先搜索或广度优先搜索的同时能够保护图数据的结构信息。

\paragraph{基于hop的索引算法}

基于hop的索引算法是目前图数据上可达性查询算法中最为流行的一种索引算法，该类算法通常不需要像传递闭包那么大的索引空间同时也比在线搜索要快。基于hop的索引算法最先提出的是\cite{cohen}中的2-hop。在2-hop算法中，图中每个顶点的可达性信息都用两个集合，我们称之为$\lin$和$\lout$来进行标识。这些所有的$\lin$和$\lout$构成了整个图数据的传递闭包集合。为了判断两个点$u$是否可以到达$v$，我们只需要检查$\lout(u)$和$\lin(v)$的交集是否为空即可，若不为空，则说明顶点$u$可以到达顶点$v$，若为空，则说明不可达。为了进一步提高2-hop的查询和索引效率，很多基于2-hop的延伸工作\cite{pathhop,sigmod2013,3hop}来提高原始的2-hop的索引和查询效率。同时，先前也有很多研究工作\cite{chengjf1,chengjf2,hopi}来优化2-hop的索引大小以及它的高昂的计算，使得2hop能够支持更大的图，生成索引效率越高也降低最后的索引的大小。\cite{sigmod2013}文章中，作者提出了一个类似于2-hop的索引方法，该方法大幅度的提升了查询的效率，降低了索引的大小同时索引的开销也是变得可以接受。同时，也有一些工作\cite{byron}注重于如何在建立好的索引基础上，高效的完成增量维护。

由于2-hop具有非常简单的索引结构，同时基于2-hop的可达性查询方法也仅仅只有一个交集计算。在本文中，我们基于2-hop来完成我们基于隐私保护的可达性查询算法。很多基于2-hop的延伸算法可以很简单的应用到我们的系统中。

\section{本章小结}

在本章中，我们简要的介绍了目前在图数据库领域中，在隐私保护以及图的可达性查询算法方面的一些文章。并对各种算法进行了简要的分析，总结了各种算法优点与缺点，并考虑了如果将各种算法应用到我们研究问题上所难以解决的问题。同时，我们对目前图中最基础的可达性查询算法进行简要的分类，总结每一类算法的特点，最后我们根据各类算法的特点，简要说明了在本文中，我们基于2-hop算法进行研究的好处与意义。
