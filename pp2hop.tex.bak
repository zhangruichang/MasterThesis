\chapter{图上可达性查询的隐私保护算法}
\rhead{图上可达性查询的隐私保护算法}

在本章中，我们重点详细介绍隐私保护的\hop 索引算法。在~\ref{sec:opt}节中，我们介绍一种新的启发式算法来代替$\maxDC$，使用该启发式算法能够使得\hop 索引最终的$\maxintr$能够尽可能的最小化。在~\ref{sec:add} 中，我们提出了一种新的贪心算法，通过往~\ref{sec:opt} 中得到的\hop 索引的$\lin$s和$\lout$s中加入尽可能少的代理点使得最终的所有的$\lin$s和$\lout$s两两的交集大小是完全一致。在~\ref{sec:encrypt}中，我们通过一定的加密算法对\hop 索引进行加密。在~\ref{sec:query} 中，我们详细介绍在加密的索引条件下，安全的可达性查询如何进行。在~\ref{sec:analyse}中，我们对本文提出的隐私保护算法的隐私保护的作用进行分析。最后，我们通过实验对本文中提出的算法效果与效率进行实验的验证。


 \section{具有Imax感知的2-hop算法}
 \label{sec:opt}

首先我们给出$\maxintr$的定义：
 \begin{Definition}
对于给定的一个图$G$的\hop 索引，
$\maxintr = \forall u, v, max(|\lout(u) \cap \lin(v)|)$，
其中$u,v \in V$。
 \end{Definition}

在实际中通过$\maxDC$启发式条件构建出的$\maxintr$ 通常非常大。在我们的实验中，通过$\maxDC$ 条件建立出来的$\maxintr$平均为378。在实验中，我们会发现比较大的$\maxintr$通常会导致需要加入非常多的人工中心点以及会导致比较大的查询代价。

 在本节中，我们提出一个新的启发式条件使得在建立\hop 的过程中能够使得$\maxintr$尽可能的最小。其主要思想是在建立\hop 索引的过程中就将交集的信息考虑进去。详细的来说我们的目标主要是要去最小化以下的两个指标：
 \begin{enumerate}
 \item 和最原始的\hop 工作中一样，我们期望每次选择能够覆盖到未被覆盖的传递闭包集合$T'$中最多的元素的这样一个中心点$w$，通过这样的选择可以带来两方面的好处，一是可以使得中心点的数目较少，二是可以使得\hop 的索引大小较小;

 \item $max(|\lout(u) \cap \lin(v)|)$，也即使得所有$\lout(u)$和$\lin(v)$之间交集最大的交集大小能够尽可能的小。
\end{enumerate}

 为了实现以上的两个目标，我们提出了以下的启发式函数，我们把它称之为$\maxIS$，具体的定义如下：

 \begin{equation}\label{equ:maxIS}
    \maxIS = \frac{|\e_w \cap T'|}{max(|\lout(u) \cap \lin(v)|)},
\end{equation}

这里$u \in \l_w$, $v \in \r_w$, $T'$ 是传递闭包集合$T(\g)$中还未覆盖的的传递闭包集合条目。公式~\ref{equ:maxIS} 主要包括以下两个部分：

\begin{enumerate}%\addtolength{\itemsep}{-0.3\baselineskip}

    \item  $\e_w \cap T'$ 表示如果我们选择$w$为中心点的话，那么通过选择这个中心点可以覆盖到$T(G)$中未覆盖到的元素的条目数；

    \item  \begin{small}$max$\end{small}$(|\lout(u) \cap \lin(v)|)$表示对于所有的$u,v \in V(\g)$中$|\lout(u) \cap \lin(v)|$最大的交集集合大小。

\end{enumerate}

上面~\ref{equ:maxIS}将以上的两个目标集合起来表示，我们希望在选择一个中心点的时候，即可以包含尽可能多的未被覆盖到的传递闭包集合的元素，但是同时使得所有的$\lout$ 和$\lin$之间的交集尽可能的小，以达到我们希望在建立\hop 索引时既可以使得索引的大小较小同时使得$\maxintr$ 也尽可能的小。所以在我们的工作中我们用~\ref{equ:maxIS}公式中的$\maxIS$代替~\ref{sec:2hop}节中公式~\ref{equ:2hop}定义的$\maxDC$。


\begin{figure}
    \centering
    \includegraphics[height=2.5cm ,width=14cm]{./example/opt.eps}
    \caption{{\small 使用$\maxIS$ 选择中心点的举例}}
    \label{fig:opt}
\end{figure}


\begin{Example}

我们通过图~\ref{fig:opt}中的一个例子来说明我们的$\maxIS$启发式方法和$\cite{cohen}$中$\maxDC$启发式方法的区别。图中左边为图数据，假设在这一次迭代循环中，只有两个中心$($$w_1$和$w_2$$)$可能作为被选择的备选点。从图中可以看出$L_{w_1} = \{ u_1, u_2, u_3\}$，$R_{w_1} = \{ v_1, v_2 ,v_3\}$，$L_{w_2}= \{u_2, u_3, u_4\}$，$R_{w_2} = \{ v_2, v_3, v_4\}$。我们假设$|E_{w_1} \cap T'|$ $=$ $|E_{w_2} \cap T'|$，那么在$\maxDC$算法中，在这一次迭代的循环中，我们既可以选择$w_1$作为中心点，也可以选择$w_2$。再进一步假设$\forall u \in L_{w_1}, v \in R_{w_1}$, $max(|\lout(u)$ $\cap$ $\lin(v)|) = 4$以及$\forall u \in L_{w_2}, v \in R_{w_2}$, $max(|\lout(u)$ $\cap$ $\lin(v)|) = 5$。那么如果在我们的$\maxIS$算法中，我们只能选$w_1$作为这一次循环的中心点，因为选择它带来的好处是我们可以覆盖同样数目的未被覆盖的传递闭包集元素，同时也可以使得全局的$\lin$和$\lout$的交集较小。
\end{Example}


 \section{代理节点的添加算法}
 \label{sec:add}
在本节中我们从两个方面来介绍我们的代理节点添加算法。一方面对在上一节中利用$\maxIS$启发式方法建立出的\hop 索引通过加入一些人工代理中心点使得任意$\lout$ 和$\lin$ 之间的交集大小一致。另一方面，我们通过添加人工代理中心点使得所有的$\lout$和$\lin$集合里的元素数目都具有一个用户指定阈值的差异，以防止\SP 通过基于大小的攻击方法来对索引的信息进行猜测。

\subsection{交集大小归一化}
\label{sec:imax}

交集大小归一化主要处理的问题是如何通过往\hop 索引($\lin$s和$\lout$s)中加入一些人工的代理节点来实现对于每一个$u \in V(\g)$和$v \in V(\g)$，使得添加了代理节点后的$\louts(u)$ 和 $\lins(v)$之间的交集大小为一个定值$\maxintr$。关于$\maxintr$，由于在一些非常特殊的图，比如图中所有的点基本都是孤立的，在这些非常离散的图中$\maxintr$ 要么为0要么为1，那么攻击者可能很容易通过最后的交集大小猜测到这些图的一些结构信息，比如这个图非常的离散。为了使得我们的系统能够更安全，对于这些非常特殊的图，我们可能将$\maxintr$设立一个最小值，比如设置$\maxintr$=4，这样攻击者\SP 就无法从最终的$\maxintr$获取到图的任何信息。关于安全部分的分析，具体可见~\ref{sec:analyse}。 在本节中，我们注重提出我们的交集大小归一化算法，使得通过加入最少的人工代理点让所有集合的交集大小为$\maxintr$。由于对任何的交集大小都是一样的，那么攻击者\SP 就不能从交集的结果得到关于两个查询点之间的可达性信息(在\hop 索引中，对于一个查询$\reach$($u,v$)，$\lout(u) \cap lin(v)$的集合大小表明了顶点之间的可达性信息，只有不可达的点之间的交集大小为0)。我们将这个问题称之为最少代理中心点添加({\em minimum addition of surrogate nodes}，\madd)问题。我们下面给出\madd 问题的定义。


% problem definition
\begin{Definition}\label{def:dummy}
    %
    最少代理中心点添加问题(\madd)是对于给定一个图\g 的\hop 索引，通过向$\lin$s 和$\lout$s 中添加一些人工的代理节点得到$\lins$s 和$\louts$s使得：
 %
\begin{itemize}
    %
    \item $\forall u, v \in V(\g)$, $|\louts(u) \cap \lins(v)| = \maxintr$；
    %
    \item $\lins$和$\louts$集合中最大的集合元素都最小化；
    %
    \item $\sum_{u \in V(\g)} (|\lins(u)| + |\louts(u)|)$也最小化。
    %
\end{itemize}
\end{Definition}

\begin{Lemma}
\label{theo:madd}
最少节点添加问题$($\madd$)$是一个NP-hard问题。
\end{Lemma}

我们给出对于引理~\ref{theo:madd}的证明，最少代理中心点添加问题的复杂度可以从一个经典的最小顶点覆盖问题得到。关于最小顶点覆盖问题({\sc minimum vertex cover} problem (\mvc))定义如下：给定一个图$G = (V, E)$，寻找顶点集$V$的一个最小子集$V'$使得对于图中的每一条边$(u, v) \in E$，顶点$u$或者顶点$v$至少有一个在集合$V'$ 中。

考虑最小顶点覆盖问题的一个实例图$G = (V, E)$，我们可以通过以下的方法构造一个最少代理节点添加问题的实例 ：对于任何一个$v_i \in V$，$v_i$和一个可以添加到\hop 的$\lin$s或$\lout$s中的一个代理节点$d_i$相对应，图中的一条边$(v_i, v_j) \in E$表示集合$\lin$($a_i$) $\cap$ $\lout$($b_j$)的一个交集。我们通过特殊的构造方法构造出$\lin$s和$\lout$s使得其满足以下两个条件：
\begin{enumerate}
\item 通过添加$d_i$或$d_j$到$\lin$($a_i$)和$\lout$($b_j$)中，使得$|$$\lin$($a_i$) $\cap$ $\lout$($b_j$)$|$ 恰好等于$\maxintr$；
\item 添加$d_i$或$d_j$到$\lin$($a_l$) 或 $\lout$($b_m$)中，在图$G$表示为一条边($v_l$, $v_m$)，将使得$|$$\lin$($a_l$) $\cap$ $\lout$($b_j$)$|$ $>$ $\maxintr$或者$|$$\lin$($a_i$) $\cap$ $\lout$($b_m$)$|$ $>$ $\maxintr$，这里$v_i \not = v_l$ ，$v_j \not = v_m$.
\end{enumerate}

\begin{algorithm}
 \caption{交集大小归一化算法$\unifyIS$($\lout$, $\lin$)}
 \label{algo:addnodes} {
 \begin{algorithmic}[1]
 \Statex {\bf Input:} \hop 索引$\lin$s 和$\lout$s
 \Statex {\bf Output:} $\louts$s和$\lins$s
    %\State \textbf{function} $map(list)$
    %\Statex {\textbf{variables:} $list$ - 包含关键词的图顶点列表}
 %   \State \quad decompose the source nodes from $list=\{n_1,\ldots,n_s\}$
    \State 计算$\maxintr$ 大小
    \State 初始化代理节点集合$D_w = [\ ]$
    \State 对图中的顶点$V(\g)$创建一个优先级队列$Q_v$，在队列中，各个点$v \in V(\g)$的优先级定义如下：
    \Statex \quad $max$$_{u\in V}$($\maxintr$ - $|$$\lout$($u$) $\cap$ $\lin$($v$)$|$)
    \State {\bf while} $v \not = {\tt null}$，其中$v$ $\leftarrow Q_v$.$\next$() \quad \quad //{扫描 $\lin$s}
    \State \quad $D_w$.${\tt movetofront}()$ \quad \quad //将数组指针移到$D_w$的最前面
    \State \quad {\bf while} $d_i \leftarrow D_w$.$\next$()
    \State \quad \quad {\bf if} $d_i$ = ${\tt null}$ 并且 $\exists u',v'$ $|\lout(u') \cap \lin(v') | < \maxintr$
    \State \quad \quad \quad $d_i$ $\leftarrow$ ${\tt new}$ ${\tt node}$() 同时 $D_w$.${\tt push}$($d_i$)
    \State \quad \quad {\bf else} break\\
    \State \quad \quad {\bf for each} $u \in V(\g)$, 且 $|\lout(u) \cap \lin(v) | < \maxintr$ \quad \quad //{扫描 $\lout$s}
    \State \quad \quad \quad //如果交集大小约束条件满足
    \State \quad \quad \quad {\bf if} $\psi$(\hop, $u$, $v$, $d_i$) 条件为真
    \State \quad \quad \quad \quad $\lout(u)$$\leftarrow$$\lout(u)$$\cup$$\{d_i\}$; $\lin(v)$$\leftarrow$$\lin(v)$$\cup$$\{d_i\}$
    \State {\bf return} $\lout$s和$\lin$s中添加了代理中心点后的$\louts$s和$\lins$s
  \end{algorithmic} }
\end{algorithm}

以上的两条规则说明了$d_i$ 或 $d_j$只能被加入到$\lin$($a_i$) 和 $\lout$($b_j$)中。最后我们再将原先真实的中心点加入到$\lin$和$\lout$中使得得到的$\lin$s和$\lout$s都分别具有相同的大小。因此\madd 问题关于使得$\linmax$和$\loutmax$最小化的限制在这里变得无效。通过这种方法得到的\hop 索引的大小最大为 $|V|\maxintr \times 2|V|$，这里$maxintr$是对于对于每一个$v_i \in V$需要满足第二个条件要添加的的点的数量，2$|V|$是所有的$\lin$s和$\lout$s的数量。

假设我们已经找到关于\madd 中代理中心点集合$D_w$的一个解决方案，在该算法中所有的交集大小都是$\maxintr$ $D_w$。那么首先，$d_i$ 或者$d_j$已经被添加到所有的可能的$\lin$($a_i$) $\cap$ $\lout$($b_j$)的集合中。这里每一个可能的集合都是一条边，表示为$C$ = $\{v_i$ | $d_i$ $\in$ $D_w\}$，那么$C$就是一个最小顶点覆盖。我们可以很容易的得到只有在$C$能够有最小化的答案时，$D_w$才能够有最小化的答案。因此我们从 \madd 的一个解决方案中得到了 \mvc 的一个解决方法，但是由于 \mvc 是一个NP-hard问题，所以以上的\madd 也是一个NP-hard问题。


针对以上的\madd 这样一个NP-hard问题，在本文中，我们提出了一个贪心算法，叫做\unifyIS 算法来解决这一问题。关于\unifyIS 算法详细见算法~\ref{algo:addnodes}。\unifyIS 算法的输入是前面一章节中算法生成的\hop 索引，也就是$\lin$s 和$\lout$s。算法的输出为添加了代理中心点的\hop 索引，为了与前面的标识相区别，我们将其标记为$\louts$s和$\lins$s。算法的主要思想是对于每一个代理中心点$d$我们期望它可能加入尽可能多的$\lin$s 和$\lout$s中，规模为$O$($|V|$)。那么通过往$O$($|V|$)规模的$\lin$s和$\lout$s中加入一个代理中心点使得$T$($\g$)中有$O$($|V|^2$)级别的元素能够受益于当前加入的代理中心点。具体来说，在算法的第2行中，我们使用了一个队列$D_w$来保存当前已加入到\hop 索引中的代理中心点的ID。在算法第3-4行，\unifyIS 首先选择处理$\lin$s与其他的$\lout$s的交集与$\maxintr$有较大差距的$\lin$s。因为之前已经加入到部分的$\lin$s 中的代理中心点可以用来减小当前的$\lin$s与其他$\lout$s之间的差距，所以在算法的第5行中，对代理中心点队列$D_w$ 进行扫描，寻找当前的代理中心点集合中可以重复利用的中心点。在算法的第6-14行，算法对于每一个$\lout$s进行处理。在第7行中，算法检查是否存在一个$\lout$需要被处理，也即$\lin$与当前的$\lout$的交集大小小于$\maxintr$($| \lout(u) \cap \lin(v) | < \maxintr$)。如果以上的条件满足，那么如果之前的所有代理节点已经被利用，那么就新生成一个代理节点，否则如果上面的条件不满足，则算法跳出这次迭代。如果对于选中的一个代理节点，我们检验如果将其加入到$\lout(u)$和$\lin(v)$中如果能否满足：

\begin{equation}
    %
\begin{array}{ll}
    %
    \psi({\tt 2{-}hop}, u, v, d_i): & \forall v', |(\lout(u) \cup \{d_i\}) \cap \lin(v')| \le \maxintr ~ \wedge \\
    & \forall u', |\lout(u') \cap (\lin(v) \cup \{d_i\})| \le \maxintr,
    %
\end{array}
    %
\end{equation}
其中$u', v' \in V(\g)$。

如果当前的代理中心点$d_i$能够满足上面的条件$\psi$，那么我们则将其添加到$\lout(u)$和$\lin(v)$。该算法当所有的$u,v \in V(\g)$满足$|\lout(u) \cap \lin(v)| = \maxintr$时，算法结束。

算法\unifyIS 在最坏的情况下需要往\hop 索引中加入$\maxintr |V|$个不同的代理中心点，在最好的情况下只需要$\maxintr$个代理中心点。因此，\unifyIS 算法在最坏的情况下，需要向\hop 中加入总共$\maxintr|V|(1 + |V|)$ 个点，那么也即使索引的大小增加了$\maxintr|V|(1 + |V|)$，在最好的情况下，我们总共只会使原来的\hop 索引大小增加$2\cdot \maxintr|V|$，这里$|V|$是图$\g$中顶点的个数。

\begin{figure}[t]
\centering
\includegraphics[height=4cm ,width=10cm]{./example/2hop.eps}
%\caption{图~\ref{fig:graph} 加完代理节点后的\hop 索引}
\caption{添加完代理节点后的\hop 索引}
\label{fig:2hopAdd}
\end{figure}


\begin{Example}
在图~\ref{fig:2hopAdd}中我们展示了在图~\ref{fig:graph}中的原始\hop 索引的基础上，通过向索引里加入代理中心点使得任意两个集合的交集大小变为一致。在图中，我们使用加粗的ID表示是图数据原始的\hop 索引中真实的中心点，其他非粗体的ID表示我们人工加入的代理中心点。在该图中，它的$\maxintr$=$3$。

我们首先来考虑算法\unifyIS 的第一次迭代，由于$\maxintr$ -$|$$\lin$$(0)$$|$ $\cap$ $|$$\lout$$(1)$$|$ = $\maxintr$，所以顶点$0$是当前优先级队列中排名最高的一个顶点，同时很明显，很多的$\lin$和$\lout$之间的交集大小明显小于$\maxintr$，并且此时由于$D_w$为空集，所以暂时没有代理节点可以利用，故我们在第$8$行程序中新建了一个代理节点$7$。由于代理节点$7$并不违反$\psi$条件，所以我们将代理节点$7$加入到集合$\lin$$(0)$和$\lout$$(1)$中，使得这两个集合之间的交集大小增加$1$，同时由于$\lin$$(0)$和$\lout$$(0)$，$\lout$$(2-6)$之间的关系都不违反$\psi$条件，所以我们也将代理节点$7$添加到集合$\lout$$(0)$，$\lout$$(2-6)$中。在接下来的几次循环中，\unifyIS 添加了新的代理节点$8$和$9$到$\lin$$(0)$
和相应的$\lout$s中使得$\lin$$(0)$和所有的$\lout$s的交集大小都均为$\maxintr$=$3$。

在节点$0$的$\lin$处理完之后，\unifyIS 选择优先级队列中下一个顶点，比如$1$，然后\unifyIS 算法首先在已经存在的代理节点中查找看是否有可以重复利用的代理节点，比如代理节点$7$，因为在$\lin$$(1)$中加入该代理节点不会违反$\psi$条件，所以将代理节点$7$加入到$\lin$$(1)$，是的$\lin$$(1)$与含有代理节点$7$的$\lout$s之间的交集大小增加$1$。 基于同样的原理，代理节点$8$也被加入到$\lin$$(1)$中。但是，代理节点$9$不能再被重复利用，因为此时$|$$\lin$$(1)$ $\cap$ $\lout$$(1)$$|$ = $|$\{{\bf 1}, $7$, $8$\}$|$ = $\maxintr$，如果我们再将$9$加入$\lin$$(1)$，那么会使得$\lin$$(1)$和$\lout$$(1)$的交集大小变为$4$，从而大于了$\maxintr$，违反了条件的要求。

我们考虑图~\ref{fig:2hopAdd}中的代理节点$7$，它被插入到$13$个不同的集合中，然后它却覆盖到$T(\g)$中的$6*7$个元素，我们通过重复利用代理节点，使得\hop 索引增加的大小最小化。通过往\hop 索引中添加入一些人工的代理节点，我们使得任意的查询点$u$和$v$，他们之间的交集大小始终为定值$\maxintr$。我们仍然考虑前面例子中的查询，$\louts(1) \cap \lins(5) = \{{\bf 5}, 7, 8\}$ 和 $\louts(6) \cap \lins(0) = \{7, 8, 9\}$，对于原先无论可达或不可达的查询，他们的结果始终是一样的大小，这样也就使得攻击者无法根据查询结果判断两个查询点之间的可达性关系，因为任何的查询，其查询结果交集大小是完全一样的。
\end{Example}

\subsection{$\lin$和$\lout$大小归一化}

由于在上一节中，最少代理中心点添加问题已经是NP-hard问题了，所以我们在算法中只考虑了如何使得任何两个集合之间的交集大小变为一致，但是通常由\unifyIS 算法建立出来的$\lins$s和$\louts$s集合的元素个数差距会比较大。为了防止攻击者通过利用集合大小的信息对图中一些中心点的链接关系进行猜测，我们在这一节提出了一种后处理的$\lins$s和$\louts$s集合大小归一化的处理算法$\unifylin$。由于对$\lins$和$\louts$的归一化是完全一样的一个过程，所以为了文章的简洁性，我们在这里只讨论如何归一化$\lins$，对于$\louts$可以使用和$\lins$ 完全一样的算法进行处理。

我们使用$\linmax$和$\loutmax$分别表示在$\lins$s和$\louts$s中具有最大集合大小的集合$\lins$ 和$\louts$。 我们的算法的主要思想基于以下的两方面想法：(1)对于图$\g$中的任何一个顶点$u \in V(\g)$，如果$|$$\lins$($u$)$|$ $<$ $\linmax$，我们通过将$\lins$($u$)集合里面的代理节点进行分裂，使得$\lins$($u$)的大小接近$\linmax$的大小；(2)我们在对任何点的分裂过程中，算法要保证不增加$\maxintr$的大小。下面我们给出这个问题的一个严格定义，我们称该问题为索引大小归一化问题(Unification of the Labeling Size，\uls)。

\begin{Definition}\label{def:uls}
    %
    索引大小归一化问题(Unification of the Labeling Size，\uls )是指给定集合$\lins$s和$\louts$s，我们希望通过一定的算法使得它们的集合大小能够
    $\forall u, v$,
    %
    \begin{center}
        %
        {\large$\frac{||\lins(u)| - \linmax|}{\linmax}$} $\leq \delta$ 和
        {\large$\frac{||\louts(u)| - \loutmax|}{\loutmax}$} $\leq \delta$,
        %
    \end{center}
    %
    在这里 $\delta$ 是一个用户指定的参数，该参数规定索引大小之间的差距允许的误差。
\end{Definition}


\begin{algorithm}
 \caption{$\lins$s集合大小归一化算法 $\unifylin$($\louts$s, $\lins$s, $\delta$)}
 \label{algo:splitnodes} {
 \begin{algorithmic}[1]
 \Statex {\bf Input:} 添加完了代理节点后的\hop 索引$\louts$和$\lins$，以及用户自定义的误差阈值的参数$\delta$
 \Statex {\bf Output:} $\louts$和$\lins$

 \State {\bf for each} $u \in V(\g)$，$|\lins(u)| + \linmax *\delta \leq \linmax$
 \State \quad 从集合$\lins$($u$)中选取一个人工代理节点$w$
 \State \quad 将原先的代理节点$w$分裂成一个集合$W$ = $\{w_1, \cdots, w_n, w_{n+1}\}$, $n$ $\le$ $\linmax -|\lins(u)| - 1$
 \State \quad 我们将点$w$从原先的集合$\lins$($u$)中移除并将集合$W$中的所有元素添加到集合中，即$\lins(u) \leftarrow (\lins(u) / \{w\}) \cup \{w_1, \cdots, w_{n+1}\}$
 \State \quad {\bf for each $u' \in V(\g)$}，$|$$\lins$($u'$)$|$ $<$ $\linmax$ $\wedge$ $w$ $\in$ $\lins$($u'$)
 \State \quad \quad $\lins(u') \leftarrow (\lins(u')/\{w\}) \cup \{w_{n+1}, w_{n+2}\}$
 \State \quad {\bf for each $v \in V(\g)$}，$|$$\louts$($v$)$|$ = $\loutmax$ $\wedge$ $w \in \louts(v)$
 \State \quad \quad $\louts(v) \leftarrow \louts(v) \cup \{w_{n+1}\}$
 \State \quad {\bf for each $v \in V(\g)$}，$|$$\louts$($v$)$|$ $<$ $\loutmax$ $\wedge$ $w \in \louts(v)$
 \State \quad \quad $\louts(v) \leftarrow \louts(v) \cup \{w_i, w_{n+2}\}$
 \Statex \quad \quad 其中$i \in$ [1,$n$]，并且每一个$i$都至少一次被加入到$\louts$中
  \end{algorithmic} }
\end{algorithm}

我们在算法~\ref{algo:splitnodes}中介绍了\unifylin 算法来解决索引归一化问题。假设我们首先对所有的$\lins$按照它们集合的大小进行从大到小进行排序，我们根据排序的情况，对所有的$\lins$使用\unifylin 算法。我们首先在算法的第1-2行中，从集合$\lins$($u$)中选择一个人工代理中心点$w$。在算法的第3行中，我们根据选择的代理中心点生成一个新的代理中心点集合\{$w_1, \cdots, w_n$, $w_{n+1}$\}，其中$n$ $\le$ $\linmax$ - $|$$\lins$($u$)$|$ - 1。在算法第4行中，我们使用\{$w_1,\cdots, w_{n+1}$\} 代替原先$\lins$($u$)中的节点$w$。在算法的第5-6行，我们对于任何一个$u' \in V(\g)$，$w$ $\in$ $\lins$($u'$) 且 $|$$\lins$($u'$)$|$ $<$ $\linmax$，我们使用$w_{n+1}$ 和$w_{n+2}$ 代替集合 $\lins$($u'$) 中原先的$w$。在算法的第7-8行，对于那些$v \in V(\g)$，它的$|$$\louts$($v$)$|$ = $\loutmax$ 并且 $w \in \louts(v)$，我们则向这些$\louts$($v$)集合中添加一个新的代理节点$w_{n+1}$。在算法的第9-10行，对于所有的满足 $|$$\louts$($v$)$|$ $<$ $\loutmax$ 且 $w \in \louts(v)$的顶点$v$，我们在集合$\louts(v)$中添加新的代理节点\{$w_i$, $w_{n+2}$\}，其中$i \in$ [1,$n$]。


\begin{figure}[t]
\centering
\includegraphics[height=3.5cm ,width=11cm]{./example/split.eps}
\caption{\unifylin 算法一次迭代的中间结果以及$\lins(6)$的加密}
%\caption{图~\ref{fig:2hopAdd}中\unifylin 算法一次迭代的中间结果以及$\lins(6)$的加密}
\label{fig:2hopUnify}
\end{figure}

\begin{Example}
我们利用图$~\ref{fig:2hopAdd}$中的已经使用算法$~\ref{algo:addnodes}$处理完的\hop 索引来说明算法$~\ref{algo:splitnodes}$。利用算法\unifylin 处理完的索引见图$ ~\ref{fig:2hopUnify}$。假设我们从$\lins$$(5)$中选择代理中心点$7$作为分裂中心点，由于$\linmax$ $= 7$ 并且 $|\lins$$(5)$$|$ $= 5$，所以$n+1$可以是$2$，我们将代理中心点$7$分裂为\{$7_1$, $7_2$\}。我们用\{$7_1$, $7_2$\}替换集合$\lins$$(5)$中的代理中心点$7$。同时，由于代理中心点$7$也出现在一些其他的$\lins$中，我们对于这些集合，我们向其中添加新的代理中心点\{$7_2$, $7_3$\}到集合$\lins$$(i)$, $i \in$ $\{0,1,2,3,6\}$ 中。由于$\loutmax$ = $|$$\louts$$(5)$$|$ = $|$$\louts$$(6)$$|$，我们将新的代理中心点$7_2$添加到 $\louts$$(5)$ 和 $\louts$$(6)$中。对于$\louts$$(j)$，$j$ = $\{0,1,2,3,4\}$，我们向其中添加$7_3$。
\end{Example}

我们可以使用一个很简单的例子来分析，经过\unifylin 算法处理过以后的\hop 索引的任意集合之间的交集大小并没有被改变。与此同时，由于使用\unifylin 算法而产生的一些新的代理节点将出现在部分交集结果中。通过使用\unifylin 算法，\hop 索引$\lins$和 $\louts$增加的大小主要有以下几部分：(1)$\lins$($u$)集合增加的大小为$n+1$；(2)那些含有选中的代理中心点$w$的$\lins$增加的大小为2；(3)对于含有代理中心点$w$的$\louts$，如果它的集合大小已经等于了$\loutmax$，那么它增加的大小为1；(4)对于含有代理中心点$w$ 的$\louts$，如果它的集合大小小于$\loutmax$，那么它增加的大小为2。所以在\unifylin 算法中，我们总使得距离目标远的集合的增长速度大于那些距离目标近的集合。然后我们可以交替的在$\lins$和$\louts$上使用\unifylin 算法直到每一类集合之间大小的差距满足我们在定义~\ref{def:uls}中定义的一个阈值$\delta$。


 \section{索引加密处理算法}
 \label{sec:encrypt}

 在\ref{sec:add}中我们已经介绍了如何使用\unifyIS 算法和\unifylin 算法来对原始的\hop 索引进行添加人工代理中心点使得任意两个集合之间的交集大小都等于$\maxintr$，同时使得所有的$\lins$和$\louts$的集合大小浮动都能在一个规定的阈值范围内。经过以上的处理，在本节中，我们着重介绍如何去对这些索引进行加密处理。

 为了区分在索引中，哪一些中心点是真实的中心点，哪一些中心点是我们通过算法添加的人工代理中心点，我们对于\hop 索引中的每一个中心点使用一个标志来标识它的真实与否，具体见定义~\ref{def:newlabel}。对于是真实中心点的，该标志位为0，否则该标志位为1。我们将在~\ref{sec:query}中介绍如何使用该标志位来对查询结果进行加密。下面给出在$\lins$s 和$\louts$s中新的中心点的定义。


 \begin{Definition}\label{def:newlabel}
    %
    \hop 索引$($ $\louts(u)$和$\lins(v)$ $)$中的每一个中心点都是一个二元组$($ $w$，$\f$ $)$，当该$w$中心点是一个原始\hop 中真实的中心点时$\f$ = $0$，否则该标志为$1$。
    %
\end{Definition}


基于定义~\ref{def:newlabel}，我们对所有的中心点进行加密使得既可以保护查询点之间的可达性信息也可以保护图的结构信息。(1)为了隐藏图中顶点和索引中中心点的任何联系，我们对$(w, \f)$中的$w$和$\louts(u)$，$\lins(u)$中的$u$使用带有不同盐参数的单向防冲突哈希函数来对这两类不同的点进行映射，我们把这两个不同的哈希函数分别标记为$\hash_{s_1}(w)$ 和 $\hash_{s_2}(u)$。 对于可能$w = u$，但是并不表示 $\hash_{s_1}(w) = \hash_{s_2}(u)$，其中$s_1 \not = s_2$。
(2)关于二元组中标志位的加密，我们使用乘法同态加密算法$\encrypt(\cdot)$ \cite{elgamal}来对其进行加密。采用Elgamal加密算法主要有以下两点好处：(1)由于标志位只有两种不同的值0或者1，Elgamal加密算法在加密时引入了随机数使得相同的值可以被加密成不同的密文，所以使用Elgamal加密算法能够使得标志位加密后的值变得多样化，也使得攻击者无法通过对相同的标志位进行统计来猜测到一些信息；(2)由于Elgamal加密算法是乘法同态的加密算法，所以它可以允许客户端只用进行一次解密就能够得到查询结果，这一部分详细见~\ref{sec:query}介绍。至此，我们已经完成了完整的\hop 索引的创建，所以在此我们给出隐私保护的\hop (privacy-preserving \hop\ ，\pphop ) 索引的精确定义。

\begin{Definition}
\label{def:encrypted2hop}
对于一个图$\g =(V(\g),E(\g))$，它的隐私保护的\hop $(\pphop)$索引就是对于图中每个加密的顶点$u_e$，$u_e =\hash_{s_2}(u)$ 都带有两个加密的集合$\louts(u)$和\\
$\lins(u)$$($记着$\loute(u)$，$\line(u)$$)$表示顶点$u$的可达性信息。其中对于集合$\loute(u)$，$\line(u)$中的每一个元素都是一个二元组$(\we,$ $\fe)$，其中$\we =
\hash_{s_1}(w)$ ，$ \fe = \encrypt(\f)$。
\end{Definition}


\begin{Example}
在图$~\ref{fig:2hopUnify}$中，我们就节点$6$的$\line(6)$作为一个例子进行展示。对$\line(6)$进行加密后的$\lin$我们记作为$\line$$(\hash_{s_2}$$(6))$，其中$\hash_{s_2}(6)$是对节点$6$进行加密后的密文串。同时，对于每一个集合中的元素，我们也进行加密，例如对于$\lins(4)$集合中的第一个元素$(4, 0)$，我们通过加密使其变为$(\hash_{s_1}(4), \encrypt(0))$。
\end{Example}


 \section{隐私保护的可达性查询处理}
 \label{sec:query}

基于在前一节中定义~\ref{def:encrypted2hop}中定义的加密的\pphop 索引，我们在本节中将介绍如何在不解密的条件下进行可达性查询的处理。查询处理主要有以下三个步骤：(1)首先，客户端对查询内容$\reach($$u,v$$)$进行加密，我们将查询内容从$\reach($$u,v$$)$通过哈希方法进行加密使其变为$\reach($$u_e,v_e$$)$，并将其提交到服务商\SP 进行查询；(2)在服务端\SP 对集合$\loute(u_e)$和$\line(v_e)$进行求交集操作，同时将交集后的结果$\re$返回给客户端；(3)客户端使用从数据拥有者处通过授权得到的密钥$K$通过Elgamal解密算法对返回的结果进行解密并得到最终的结果。

\paragraph{朴素查询算法}
在以上的三个步骤的前提下，朴素的可达性查询算法是对于一个查询$\reach($$u,v$$)$，我们在服务端\SP 做两个集合$\loute(u_e)$和$\line(v_e)$之间的交集，并将最后交集的结果中的中心点的加密的标志位信息全部返回给客户端。客户端对返回的所有标志位进行一一的解密，检查其中是否至少有一个标志位为0，表明交集的结果中有至少一个真实的中心点。如果有至少一个标志位解密后为0，则说明两个查询点之间是可达的，否则如果所有的标志位解密后都为1，那么说明这两个点不可达。很明显，由于在前面的算法中，我们使得对于每一个查询，其交集的结果中都有$\maxintr$个元素，所以在朴素的查询算法中，客户端需要解密$\maxintr$次，这无疑是非常耗时的。下面我们介绍一种基于乘法同态加密算法的查询处理算法。

\paragraph{基于乘法同态加密算法的查询算法}
通常我们知道解密是一个比较耗时的过程，尤其是在这种客户端可能具有较弱的计算能力的时候，所以如果能使客户端解密一次那么整个查询时间就会被大大缩短。所以我们提出了一种只需要客户端进行一次解密的查询算法。我们将点$u_e$和$v_e$的$\loute(u_e)$ 和 $\line(v_e)$交集的结果记为$R$($u_e$,$v_e$)或简记为$R$，那么

\begin{center}
$R$ = \{($\we$, $\fe$) $|$ ($\we, \fe$) $\in$ $\loute(u_e)$ and ($\we, \fe'$)
$\in$ $\line(v_e)$\}.
\end{center}

那么在基于乘法同态加密算法的查询算法中，由于我们使用的Elgamal算法支持乘法同态特性，也即在密文状态下的乘法运算等于明文状态下的先乘法再进行加密，所以我们将最终的查询结果$\re$定义为$\prod_{(\we,\fe) \in R} \fe$。我们将最终结果$\re$返回给客户端，客户端使用私有密钥$K$对查询结果$\re$进行一次解密，如果解密完结果为0， 则表示两个查询点$u$可以到达$v$，否则如果非0，则表示顶点$u$不可以到到顶点$v$。这里$\re$是交集结果中很多个标志位乘积的结果，这个乘积为0当且仅当在交集结果中至少包含有一个真实的中心点；如果交集的结果中，所有的点都是我们前面通过算法添加的代理中心点，那么解密后的$\re$应该为1。

\begin{Example}
我们考虑图$~\ref{fig:graph}$中的图数据，我们考虑在其上进行隐私保护的可达性查询$\reach($$1,5$$)$。那么在\pphop 索引上的可达性查询算法主要进行以下几个步骤：$(1)$首先客户端使用从数据拥有者处通过授权获得的盐参数$s_2$对查询点进行哈希使其成为$\hash_{s_2}(1)$ 和$\hash_{s_2}(5)$，并将哈希后的两个查询点提交到服务商\SP；$(2)$服务商进行集合交集$\loute(\hash_{s_2}(1)) \cap \line(\hash_{s_2}(5))$，并得到集合交集后的结果$\{ (\hash_{s_1}(5),$ $\encrypt(0)),$ $(\hash_{s_1}(7),$
    $\encrypt(1)),$ $(\hash_{s_1}(8),$ $\encrypt(1))\}$。基于以上交集得到的结果，服务商进行一个密文状态下的乘法运算得到$\re = \encrypt(0) \times \encrypt(1) \times \encrypt(1) = \encrypt(0)$，并将这个结果返回给查询客户端；$(3)$客户端使用从图数据拥有者处通过授权获得的解密密钥$K$和Elgamal解密程序对返回的$\re$进行一次解密，发现解密的结果为$0$，则表明顶点$1$可以到达顶点$5$。
\end{Example}


 \section{图上可达性查询的隐私保护算法的隐私分析}
 \label{sec:analyse}

 在本节中，我们针对前面在~\ref{sec:def}节中定义的攻击模型，分析本文的隐私保护算法的安全性。

\paragraph{针对密文索引的攻击}
我们在下文中证明如果在基于密文的攻击下，本文中的隐私保护可达性查询系统可以保护查询点之间的可达性信息以及图的结构信息不被攻击者\SP 攻击。

 \begin{Lemma}\label{prop:break1}
    %
    攻击者\SP 能够破解查询顶点之间的可达性信息当且仅当\SP 能够破解单向防冲突哈希算法或者Elgamal加密算法。
    %
\end{Lemma}

下面我们给出对于引理~\ref{prop:break1}的证明。首先我们分情况讨论一下，如果在攻击者\SP 能够破解哈希算法和Elgamal加密算法的情况下，它可以获得的信息，以及在它不能破解以上的两个算法条件下，它能够从系统中获取到的信息。

情况一：(1) 我们假设攻击者\SP 可以破解Elgamal 加密算法，那么\SP 就可以根据中心点的标志位推断出一个中心点是否为真实的中心点。所以在可达性查询期间，\SP 可以分析交集结果$R$，那么\SP 就可以根据分析出的交集结果中是否存在一个真实的中心点来判断两个查询点之间的可达性信息。

(2)如果攻击者\SP 可以破解哈希函数(例如SHA-1)，那么它就可以破解出$\lins$ 和 $\louts$中每一个中心点ID的未哈希情况下的原文。然后攻击者就可以通过和\pphop 中的$\lins$，$\louts$对比是否有对应的ID来判断一个点是否为真实的中心点，进而可以得到查询点之间的可达性信息。

情况二：我们假设攻击者\SP 不能够破解单向防冲突哈希函数和Elgamal加密算法。下面我们通过分析在每一步中，\SP 可以获取到的信息。对于一个给定的查询$u_e$和 $v_e$，那么\SP 首先会去\pphop 索引中检索到$\louts$($u_e$)和$\lins$($v$)，然后\SP 求得两个集合的交集，并在基于Elgamal加密后的标志位上进行乘法运算进而得到最终的返回结果$R_e$。

首先，由于攻击者\SP 无法破解哈希方法，那么它就不能解密出查询点$u_e$和$v_e$的真实的点的信息，同时，他也不能破解$\louts$($u_e$)和 $\lins$($v_e$)中中心点的信息，所以它无法在这两类点之间做一个一一映射，也即它不能得到关于查询点的任何信息，对于所有的查询，它每次获取的信息对它而言是完全一样的。同时，由于我们假设攻击者\SP 不能破解Elgamal加密算法，那么它也就不能破解$\louts$($u_e$) 和 $\lins$($v_e$)中中心点的标志位信息，进而无法确定一个中心点是真实的中心点或者是人工代理中心点。同时，由于Elgamal加密算法支持乘法同态，所以\SP 无法获知$R_e$的原文信息，进而\SP 不能获取查询点之间的可达性信息。

在以上，我们利用在进行任何两点的可达性查询时，保护了它们的可达性信息，我们可以证明\pphop 可以保护\SP 不能推测出图的任何结构信息。由于对于任何两点的查询，我们保护了\SP ，使得它不能获得任何两点之间的可达性信息，那么也就很明了的，它不能猜测出图中任何一条边的存在性，进而由于它不能获取到任何边的信息，所以它不能推断出图数据的任何结构信息。

\begin{Lemma}\label{prop:break2}
    %
    当且仅当攻击者\SP 要么可以破解单向防冲突哈希算法要么可以破解Elgamal加密算法，那么它才有可能判断图中一条边的存在性。
    %
\end{Lemma}

我们通过反证法来对这个引理进行证明。我们假设攻击者\SP 能够确定图中任何一条边($u,v$)的存在与否，那么攻击者\SP 必须至少获取到一个查询$\reach($$u,v$$)$的结果信息。在引理~\ref{prop:break1}中，我们证明了只有在\SP 能够破解了单向防冲突哈希算法或者Elgamal加密算法时，它才有可能获取到任何一个查询的的结果信息。所以攻击者\SP 只有在它要么可以破解单向防冲突哈希算法要么可以破解Elgamal加密算法的情况下，那么它才有可能判断图中一条边的存在性。

\paragraph{基于数据大小的攻击分析}
在上文中，我们针对攻击者可能进行的对密文进行攻击的情况进行了分析，在本节中，我们对基于集合大小的一些攻击手段进行分析。

\begin{Lemma}\label{prop:break3}
    %
    在算法$~\ref{algo:splitnodes}$中，如果将$\delta$设置为$0$，那么查询点之间的可达性信息将完全能够防止\SP 基于集合大小(size-based)的攻击。
    %
\end{Lemma}

我们同样使用反证法来对这个命题进行证明，我们假设攻击者\SP 可以利用size-based方法猜测到查询点$\reach($$u_e,v_e$$)$的可达性信息。因此攻击者\SP 可以从以下几个方面来获得可达性信息:(1)$\loute(u_e) \cap \line(v_e)$交集的大小；(2)$\loute(u)$ 和 $\line(v_e)$的集合大小信息。由于对于任何两个集合的交集，在我们的算法~\ref{algo:addnodes} 中，我们已经保证其交集的大小始终为$\maxintr$，同时，在算法~\ref{algo:splitnodes}中，我们将$\delta$设置为0，那么对于任何的查询点都有$|\loute(u_e)| = \loutmax$，$|\line(v_e)|= \linmax$。所以对于任何两个不同的查询，\SP 获取的基于大小的信息都是完全一样的，它无法通过集合的大小信息获取到任何对攻击有用的信息。


\begin{Lemma}\label{prop:break4}
    %
在算法$~\ref{algo:splitnodes}$中，如果将$\delta$设置为$0$，就可以防止基于集合大小(size-based)的攻击方法对图结构信息的攻击。
    %
\end{Lemma}

这一命题的证明和引理~\ref{prop:break3}类似。

在实际情况中，$\delta$不必要严格的设置为0，因为我们利用算法向$\lins$和$\lout$中加入了新的人工代理节点，使得$\lins$和$\lout$集合的大小不能直接的反映图上一个点的连通性信息，即一个度较大的点，它的$\lins$ 和$\lout$集合大小不一定也比较大，所以$\delta$不一定非要设置为0，在一个较小的范围内，$\delta$对安全性的影响不会非常的大，关于$\delta$究竟对安全信息泄露多少信息的证明，我们在这里略去它的分析。

 \section{实验结果}
 \label{sec:experiment}

 在本节中，我们通过实验验证我们提出的技术的效率以及我们对原始\hop 索引建立算法的优化效果。

\paragraph{实验设置}
我们在一台普通的PC上进行了我们的实验，机器配置有一颗i3-2310 2.10GHz 的CPU，4 GB内存并安装有Windows 7操作系统。本节中所有的算法都是用C++进行实现的，其中改进的\hop 索引建立算法是由R.Bramandia\cite{byron}提供，我们在其代码的基础上优化和修改而来。本节中所使用的哈希函数($\hash_{s_1}$ 和$\hash_{s_2}$)是使用的160-bit SHA-1算法。加密算法是使用1024-bit Elgamal加密算法。

\begin{table}[h]
\centering
\caption{合成数据集}
\begin{tabular}{|c|c|c|c|}
\hline
$\g$ & $|V(\g)|$  & $|E(\g)|$ & $|E(\g)| / |V(\g)|$ \\
\hline
\SYN-1 & 3073 & 37615 & 12.24 \\
\hline
\SYN-2 & 5651 & 15968 & 2.83  \\
\hline
\SYN-3 & 4880 & 27946 & 5.73  \\
\hline
\end{tabular}
\label{table:syndata}
\end{table}

\begin{table}
\centering
\caption{真实数据集}
\begin{tabular}{|c|c|c|c|}
\hline
$\g$ & $|V(\g)|$  & $|E(\g)|$ & $|E(\g)| / |V(\g)|$ \\
\hline
YEAST & 2361 & 7182 & 3.04 \\
\hline
ODLIS & 2909 & 18419 & 6.33 \\
\hline
ERDOS & 6927 & 11850 & 1.71 \\
\hline
ROGET & 1022 & 5075 & 4.97 \\
\hline
\end{tabular}
\label{table:realdata}
\end{table}

\paragraph{实验数据集}
在实验中，我们使用了3个人工数据集(简写为\SYN )和4个真实数据集。关于这些数据集的一些特性详见表~\ref{table:syndata}和表~\ref{table:realdata}。所有的合成数据集使用的合成算法是最近在图数据库领域比较流行的\cite{generator}文章中的合成器生成的合成数据集。我们在合成器中，通过设置$\alpha = 0.27$ 和 $\beta = 10$ 来控制图的大小和图的稀疏度。所有的真实数据集，我们都可以通过网络进行下载\footnote{
YEAST: http://vlado.fmf.uni-lj.si/pub/networks/data/bio/Yeast/Yeast.htm \\
ODLTS: http://vlado.fmf.uni-lj.si/pub/networks/data/dic/odlis/Odlis.htm \\
ERDOS: http://vlado.fmf.uni-lj.si/pub/networks/data/Erdos/Erdos02.net \\
ROGET: http://vlado.fmf.uni-lj.si/pub/networks/data/dic/roget/Roget.htm
} 。% footnote of real data

\paragraph{查询集}
对于任何的合成数据集和真实数据集，我们生成1000个随机的查询，其中50\%的查询集是从它们的传递闭包集合中随机选择的可达的查询，另外50\%是在传递闭包集合之外选择的不可达的查询。

\paragraph{\hop 索引创建的启发式条件}
我们已经实现了最原始的\cite{cohen}文章中的基于
\maxDC 的\hop 索引建立算法，同时我们也比较了在\cite{chengjf2}中提出的基于$\maxC = |\e_w \cap T'|$ 的启发式条件算法。以及我们在本文中提出的具有$\maxintr$感知的$\maxIS$启发式方法。这些启发式方法可以通过结合~\ref{sec:2hop}节中的\hop 索引创建流程来生成基于不同启发式条件的\hop 索引。同时在实验中，我们将$\delta$默认设置为0。


\begin{table}[h]
\centering
\caption{最大交集集合大小$\maxintr$比较}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{$\g$} & \multicolumn{3}{|c|}{$\maxintr$}  \\
\cline{2-4}
   & $\maxDC$  & $\maxC$ & $\maxIS$ \\
\hline
\SYN-1 & 2558  & 22 & 15 \\
\hline
\SYN-2 & 17  & 7 & 3 \\
\hline
\SYN-3 & 1169  & 48 & 13 \\
\hline
\end{tabular}
\label{table:maxintr}
\end{table}


\subsection{合成数据集上的实验}

\paragraph{\maxIS 的作用比较}
在表~\ref{table:maxintr}中，我们比较了在三种不同的启发式条件下，建立出的\hop 索引中的最大的交集集合大小$\maxintr$的比较。我们可以从表中很明显的看出,通过$\maxIS$启发式条件创建出的索引的最大交集集合大小$\maxintr$要比$\maxDC$ 和$\maxC$启发式条件要小很多。其主要原因，我们在利用$\maxIS$ 启发式条件创建\hop 索引时，在每一次迭代中我们总是将最大交集集合的大小考虑到索引的建立过程中，所以每次我们总是选择能够使得$\maxintr$尽可能小的中心点加入到$\lin$和$\lout$中。从具体的实验数据来看，$\maxIS$平均要比$\maxDC$ 和 $\maxC$的实验效果要好88倍和2.5倍。同时，我们看到一个有趣的现象，虽然$\maxC$启发式条件在每次选择时并没有考虑到选择对$\maxintr$的影响，但是它的结果也是比较好的，其主要原因在于$\maxC$每次都选择能够覆盖最多未覆盖的传递闭包集合$T(\g)$的最多元素的中心点，所以这使得可能使用较少的中心点覆盖到所有的传递闭包集合的信息，通过我们的实验发现这有时候会使得$\maxintr$会相对较小，但是相比于我们的启发式方法，它的结果并不是最理想的。

\begin{table}[h]
\centering
\caption{总共添加的代理节点数量比较}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{$\g$} & \multicolumn{3}{|c|}{\nadd\ vs. \madd}\\
\cline{2-4}
   & $\maxDC$  & $\maxC$ & $\maxIS$ \\
\hline
\SYN-1 & 7.86M vs. 12.11K  & 67.61K vs. 17.30K & 46.10K vs. 13.73K \\
\hline
\SYN-2 & 96.07K vs. 8.75K & 39.56K vs. 6.24K & 16.95K vs. 6.08K \\
\hline
\SYN-3 & 5.70M vs. 23.03K & 0.23M vs. 18.92K & 63.44K vs. 11.11K \\
\hline
\end{tabular}
\label{table:additiondummy}
\end{table}

\paragraph{\unifyIS 算法效果}
接下来，我们比较交集大小归一化\unifyIS 算法在不同的$\maxintr$条件下的效果。在表~\ref{table:additiondummy}中我们展现了对于在不同的情况下，利用\unifyIS 算法(算法~\ref{algo:addnodes})总共添加的代理节点的数量和一个最朴素的添加代理节点的算法(Naive)比较。朴素的代理节点添加算法每次都选择一个新的代理节点添加到\hop 索引中，而不考虑重复利用之前已经使用过的代理节点。从表格中的结果中我们可以看出，在任何不同的启发式条件下，我们的\madd\ 添加的总共的代理节点数量总是至少比朴素的代理节点添加算法要少3倍左右。同时，我们注意到，在利用$\maxIS$启发式条件下，由于$\maxintr$一直都是最小的，然后我们在对比表中不同启发式条件下添加的代理节点的数量，可以看出，具有较小的$\maxintr$添加的代理节点数要比较大的$\maxintr$要少很多，所以说明我们的算法中，使得$\maxintr$尽可能小可以使得最终的索引大小也相对小很多，我们的索引方法在三类不同的启发式方法中，效果仍然是最优的。


\begin{table}[h]
\centering
\caption{\SP\ 和客户端查询时间}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{$\g$} & \multicolumn{3}{|c|}{服务端\SP\ (ms) vs. 客户端(ms)}  \\
\cline{2-4}
   & $\maxDC$ & $\maxC$ & $\maxIS$ \\
\hline
\SYN-1 & 106.54 vs. 0.52 & 2.55 vs. 0.43 & 2.02 vs. 0.46 \\
\hline
\SYN-2 & 2.01 vs. 0.56 & 1.37 vs. 0.67 & 1.79 vs. 0.47 \\
\hline
\SYN-3 & 52.35 vs. 0.54 & 4.44 vs. 0.52 & 2.15 vs. 0.52 \\
\hline
\end{tabular}
\label{table:querytime}
\end{table}

\begin{table}[h]
\centering
\caption{\SP 端吞吐量}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{$\g$} & \multicolumn{3}{|c|}{\SP\ (查询量/秒)}  \\
\cline{2-4}
   & $\maxDC$ & $\maxC$ & $\maxIS$ \\
\hline
\SYN-1 & 9 & 392 & 495 \\
\hline
\SYN-2 & 495 & 730 & 559 \\
\hline
\SYN-3 & 19  & 225  & 465 \\
\hline
\end{tabular}
\label{table:throughput}
\end{table}

\paragraph{\pphop 查询效率以及系统吞吐量}
在表~\ref{table:querytime}中，我们列出了对于一个可达性查询在\SP 端和客户端所需要的时间，表中的所有时间，是1000个查询的平均时间。对于在\SP 端的时间，由于$\maxIS$启发式方法生成的$\maxintr$较小，所以\SP 端需要进行的基于密文的标志位的乘法次数要少很多，所以在所有的实验中，$\maxIS$ 的查询时间是最好的。对于数据集SYN-1和SYN-3，$\maxIS$启发式方法要比$\maxDC$效率高至少一个数量级，对于数据集SYN-2，$\maxIS$的查询时间要比$\maxDC$快至少两倍。对于客户端的查询时间，由于所有的情况下，客户端只需要对$R_e$进行一次解密即可，而且对于任何的解密，解密程序几乎做相同数量的计算，所以对于所有的不同情况，在客户端的时间都是差不多相同的，并且都比较小。

在查询效率的基础上，我们在表~\ref{table:throughput}中计算了\SP 端的吞吐量，计算结果表明，对于一台普通的计算机，对于使用$\maxIS$启发式方法建立的索引，服务端\SP 可以提供每秒钟500次的查询，与其他的启发式方法建立的索引对比来看，$\maxDC$的吞吐量是最低的，虽然有时候$\maxIS$具有较好的吞吐量，但是它对数据集比较敏感，不同的数据集它的吞吐量的变化非常大。


\subsection{真实数据集上的实验}

我们在四个真实的数据集上，进一步验证我们的算法在真实数据集上的效果。由于得到的结果和上面分析的合成数据集比较相似，我们在这里就展示一些比较有亮点的实验结果。

\begin{table}[h]
\centering
\caption{最大交集集合大小$\maxintr$比较}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{$\g$} & \multicolumn{3}{|c|}{$\maxintr$}  \\
\cline{2-4}
   & $\maxDC$ & $\maxC$ & $\maxIS$ \\
\hline
YEAST & 237 & 6  & 4 \\
\hline
ODLIS & 274 & 3 & 3 \\
\hline
ERDOS & 250 & 5 & 3 \\
\hline
ROGET & 752 & 6 & 4 \\
\hline
\end{tabular}
\label{table:realmaxintr}
\end{table}

\begin{table}[h]
\centering
\caption{总共添加的代理节点数量比较}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{$\g$} & \multicolumn{3}{|c|}{\nadd\ vs. \madd}\\
\cline{2-4}
   & $\maxDC$  & $\maxC$ & $\maxIS$ \\
\hline
YEAST & 0.56M vs. 7.72K & 14.17K vs. 2.81K & 9.44K vs. 2.72K \\
\hline
ODLIS & 0.80M vs. 8.39K & 8.73K vs. 2.98K & 8.73K vs. 2.98K \\
\hline
ERDOS & 1.73M vs. 8.86K & 34.64K vs. 7.03K & 20.78K vs. 7.01K \\
\hline
ROGET & 0.77M vs. 3.75K & 6.13K vs. 1.40 & 4.09K vs. 1.28K \\
\hline
\end{tabular}
\label{table:realadditiondummy}
\end{table}

\begin{table}[h]
\centering
\caption{\SP\ 和客户端查询时间}
\begin{tabular}{|c|c|c|c|}
\hline
\multirow{2}{*}{$\g$} & \multicolumn{3}{|c|}{\SP\ (ms) vs. Client (ms)}  \\
\cline{2-4}
   & $\maxDC$ & $\maxC$ & $\maxIS$ \\
\hline
YEAST & 12.38 vs. 0.58 & 0.89 vs. 0.50 & 0.73 vs. 0.47 \\
\hline
ODLIS & 13.33 vs. 0.68 & 0.59 vs. 0.50 & 0.65 vs. 0.53 \\
\hline
ERDOS & 11.98 vs. 0.55 & 1.34 vs. 0.59 & 0.97 vs. 0.52 \\
\hline
ROGET & 31.91 vs. 0.64 & 0.57 vs. 0.59 & 0.29 vs. 0.64 \\
\hline
\end{tabular}
\label{table:realquerytime}
\end{table}

表~\ref{table:realmaxintr}中展示了真实数据集在不同的启发式方法下最大交集大小$\maxintr$的大小情况。本文中提出的$\maxIS$相比于$\maxDC$和$\maxC$都具有较小的$\maxintr$。由于$\maxIS$启发式算法产生的$\maxintr$是最小的，进而从表~\ref{table:realadditiondummy}中可以看出，利用\unifyIS 算法添加的总的代理节点的数量也是三种不同的启发式方法中最少的。服务端\SP 和客户端的查询时间见表~\ref{table:realquerytime}，在服务端基于$\maxIS$建立的索引，它的查询时间几乎总是要比$\maxDC$快至少一个数量级以上。同时，和在合成数据集上的结果类似，由于客户端仅仅需要解密一次，所以客户端的时间都基本一致。

 \section{本章小结}

 在本章中，我们提出了一种隐私保护的可达性查询的索引建立算法和查询算法。我们提出了一种新的建立\hop 索引的启发式算法，使得在建立\hop 索引在选择中心点时既可以考虑尽可能覆盖到尽可能多的传递闭包集合元素同时使得全局的$\maxintr$最小化，在此建立的\hop 索引的基础上，我们提出了交集大小归一化算法和集合元素大小归一化两个不同的算法以及对\hop 索引进行加密来建立一种可以保护图数据结构和查询的可达性信息的\pphop 索引。最后我们在\pphop 索引的基础上，提出了一种基于密文域的可达性查询算法，通过利用乘法同态加密的特性，我们进一步优化查询算法，使得客户端仅仅需要进行一次解密就可以获得查询结果。然后我们对本文提出的隐私保护的可达性查询算法进行隐私安全的分析，证明我们的方法是可以实现对图数据结构和查询点之间的可达性信息进行保护。最后，我们通过一系列实验，来评估了我们方法的效率和方法的可行性。
