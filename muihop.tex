\chapter{模拟数据，真实数据上的实验结果，及比较分析}
\rhead{实验结果}

\section{性能分析}
这一节中，我们用模拟数据和真实数据来评估我们方法的性能。我们将我们的方法和现有的MetaCluster3.0/5.0，AbundanceBin和MCluster进行了对比，MCluster是最近的元基因组聚类的非监督方法。

\section{数据集}
\subsection{模拟数据}
数据由MetaSim\cite{richter2008metasim} (一个基因组和元基因组序列模拟软件)生成。我们从物种丰度各异的物种中采样出元基因组序列数据。

由于MetaCluster3.0 在长序列上表现良好，我们模拟了不同物种丰度和物种个数(从2到10)的长序列数据, 16个物种表示为D1到D16，我们同样生成了相对高丰度的序列(50k和500k序列)，因为AbundanceBin是专门处理高丰度的序列。10个数据集分别称为S1到S10。这些数据集的细节列在表
\ref{tab:1}和表\ref{tab:2} 中。
\begin{table}[htbp]
    \centering
    \caption{低丰度的模拟数据(序列平均长度1000bp).}
    \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{数据集} & \textbf{序列数}  & \textbf{物种数} & \textbf{丰度比} \\
    \hline
    D1    & 5k  & 2     & 1:1   \\
    \hline
    D2    & 5k  & 2     & 1:2  \\
    \hline
    D3    & 5k  & 2     & 1:4   \\
    \hline
    D4    & 5k  & 2     & 1:6   \\
    \hline
    D5    & 5k  & 2     & 1:8   \\
    \hline
    D6    & 5k  & 2     & 1:10  \\
    \hline
    D7    & 5k  & 2     & 1:12   \\
    \hline
    D8    & 5k  & 3     & 1:1:1  \\
    \hline
    D9    & 5k  & 3     & 1:3:9  \\
    \hline
    D10   & 5k  & 4     & 1:3:3:9  \\
    \hline
    D11   & 5k  & 5     & 1:1:1:1:1  \\
    \hline
    D12   & 5k  & 5     & 1:1:3:3:9  \\
    \hline
    D13   & 5k  & 10    & 1:1:1:1:1:1:1:1:1:1  \\
    \hline
    D14   & 50k  & 3     & 1:3:9  \\
    \hline
    D15   & 50k  & 4     & 1:3:3:9  \\
    \hline
    D16   & 50k  & 5     & 1:1:3:3:9  \\
    \hline
    \end{tabular}
    \label{tab:1}
\end{table}

\begin{table}[htbp]
    \centering
    \caption{相对高丰度的模拟数据(序列平均长度1000bp).}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{数据集} & \textbf{序列数}  & \textbf{物种数} & \textbf{丰度比} \\
    \hline
    S1    & 50k  & 2     & 1:1   \\
    \hline
    S2    & 50k  & 3     & 1:1:1  \\
    \hline
    S3    & 50k  &  3     & 1:3:9   \\
    \hline
    S4    & 50k  &  5     & 1:1:3:3:9   \\
    \hline
    S5    & 50k  &  10     & 1:1:1:1:1:1:1:1:1:1   \\
    \hline
    S6    & 500k  &  2     & 1:1   \\
    \hline
    S7    & 500k  &  3     & 1:1:1  \\
    \hline
    S8    & 500k  & 3     & 1:3:9   \\
    \hline
    S9    & 500k  &  5     & 1:1:3:3:9   \\
    \hline
    S10   & 500k  &  10     & 1:1:1:1:1:1:1:1:1:1   \\
    \hline
    \end{tabular}
    \label{tab:2}
\end{table}

现在真实数据集中包含了数以百万的短序列是非常常见的，因此我们模拟了两个数据集分别有一百万条长为75bp的序列，分别包含20和50个物种，称为数据集A 和B。数据集A中的20个物种中，相对测序深度为1 3 5 10的物种数各有5个物种。数据集B中的50个物种，有6个物种测序深度为6,5个物种相对测序深度为8,5个物种测序深度为10，剩下的物种测序深度为1，A和B的细节在表\ref{tab:3}中。
\begin{table}[htbp]
    \centering
    \caption{Simulated datasets of very high abundance~(read length is 75bp on average).}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{数据集} & \textbf{序列数}  & \textbf{物种数} & \textbf{丰度比} \\
    \hline
    A    & 1million  & 20     & 1 X 5:3 X 5:5 X 5:10 X 5   \\
    \hline
    B    & 1million  & 50     & 1 X 34:6 X 6:8 X 5:10 X 5   \\
    \hline
    \end{tabular}
    \label{tab:3}
\end{table}

考虑到 MetaCluster 5.0只能处理极高丰度的短序列，我们也生成了5个数据集，分别有3000k个长为128bp的短序列，并且将我们的方法与MetaCluster5.0 进行比较。这些数据集分别称为C D E F G，具体细节在\ref{tab:4}中。

\begin{table}[htbp]
    \centering {
    \caption{极高丰度模拟数据~(序列平均长度是128bp).}\label{tab:4}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{数据集} & \textbf{序列数}  & \textbf{物种数} & \textbf{丰度比} \\
    \hline
    C    & 3000k   &  2     & 1:1   \\
    \hline
    D    & 3000k  &  3     & 1:1:1  \\
    \hline
    E    & 3000k  & 3     & 1:3:9   \\
    \hline
    F    & 3000k  &  5     & 1:1:3:3:9   \\
    \hline
    G   & 3000k  &  10     & 1:1:1:1:1:1:1:1:1:1   \\
    \hline
    \end{tabular}}
\end{table}

\subsection{真实数据集}
由于NCBI的Acid Mine Drainage元基因组数据已经被大量研究，我们也采用该数据集来评价我们的方法。这个真实数据集包含2534个重叠群(contig), 序列长度为
5000bp，这些重叠群是由103462个高质量的修整过的序列组装而成。数据集包括5个已知的物种：Leptospirillum sp.Group II, Leptospirillum sp.Group III, Ferroplasma acid armanus Type I, Ferroplasma sp.Type II
and Thermoplasmatales archaeon Gpl 以及一些来自未知物种的序列。五个物种分别属于两个超界和三个属，分类图如图~\ref{fig:4}所示。序列有2534 个contig。 众所周知
对于未知物种信息的序列，我们评价聚类算法的性能比较困难，因此我们删除其中没有物种注释的序列，并得到2424个contigs，表示为数据集R1。
\begin{figure}[h!]
  \centerline{\includegraphics[width=10cm]{./example/RealDataset}}
  %[width=16cm]
  \caption{The taxonomy of species in R1.}
  \label{fig:4}
\end{figure}
\subsection{评价标准}
为了评价聚类结果，我们考虑三种度量方法，Precision(Pr)，Sensitivity(Se)以及F1-measure(F1). 假定有一个元基因组数据集包含了N个物种，并最终归到M个类中，Rij表示第i个Cluster中包含第j个物种的序列的数量。

Precision和Sensitivity的定义如下所示
\begin{equation}\label{eq5}
Pr=\frac{\sum_{i=1}^{M}\max_{j}(R_{ij})}{\sum_{i=1}^{M}\sum_{j=1}^{N}R_{ij}},
\end{equation}
\begin{equation}\label{eq6}
\begin{split}
Se=\frac{\sum_{j=1}^{N}\max_{i}(R_{ij})}{\sum_{i=1}^{M}\sum_{j=1}^{N}R_{ij}+\text{number of unclassified reads}}.
%number\;of\;unclassified\;reads}.
\end{split}
\end{equation}


上述 "unclassified reads" 表示聚类算法聚类结果中未进行归类的序列。F1-measaure定义如下所示：
\begin{equation}\label{eq7}
F1=\frac{2\ast Pr \ast Se}{Pr+Se}.
\end{equation}

\section{实验结果}
\subsection{主题个数的影响}
概率主题模型是一种非监督技术。模型中的主题信息是隐藏的，所以我们需要为每个数据集设定主题个数。此处，我们检测LDA模型中主题个数如何影响TM-MCluster 的聚类性能。我们采用D12数据集，序列来自5个物种，并且修改主题个数从2到100。图\ref{fig:5}的结果显示，当主题个数是20的时候，我们的方法可以
取得较好的聚类效果。当主题个数为2时，聚类结果差强人意。显然，太少的主题个数可能会导致信息的丢失，太多的主题个数也许会引入噪音，也会产生负面的影响。
\begin{figure}[h!]
%\centering
    \includegraphics[width=12cm]{./example/TopicAnalysis}
    %\caption{\csentence{The pipeline of the \emph{TM-MCluster} method.}
    \caption{The effect of topic number on binning performance of \emph{TM-MCluster}}
            \label{fig:5}
\end{figure}
\subsection{模拟数据集实验结果}
首先，我们将我们的方法与MetaCluster3.0 和MCluster在4个均匀分布的数据集上进行比较，数据集D1 D8 D11 D13分别包含2 3 5 10个物种。结果显示在表\ref{tab:3} 中。
\begin{table}[htbp]
\centering
    \caption{相同丰度比的模拟数据集D1 D8 D11 D12上的聚类结果。每个黑体值表示某个数据集的最优结果。}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{数据集}} & \multicolumn{3}{|c|}{\textbf{MetaCluster 3.0}}&\multicolumn{3}{|c|}{\textbf{MCluster}}&\multicolumn{3}{|c|}{\textbf{TM-MCluster}}\\
    \cline{2-10}
    &\emph{Pr}&\emph{Se}&\emph{F1}&\emph{Pr}&\emph{Se}&\emph{F1}&\emph{Pr}&\emph{Se}&\emph{F1}\\
    \hline
    D1	& \textbf{.9989}&	.9628&	.9805&	.9877&	.9877&	.9877&	.9882&	\textbf{.9882}&	\textbf{.9882}\\
    \hline
    D8	& 	.7432&	.9218&	.8229&	.9158&	.9158&	.9158&	\textbf{.9586}&	\textbf{.9586}&	\textbf{.9586}\\
    \hline
    D11	& 	.8215&	.8766&	0.8481&	\textbf{.9002}&	\textbf{.9002}&	\textbf{.9002}&	.8394&	.8394&	.8394\\
    \hline
    D13	& 	.4335&	\textbf{.8732}&	.5794&	.706&	.6894&	.6976	&\textbf{.7574}&	.7732&	\textbf{.7652}\\
    \hline
    \end{tabular}
    \label{tab:3}
\end{table}
从表\ref{tab:3}中可以看出，我们的方法在三个数据集上取得最高的F1值，在两个数据集上取得最高的precision和sensitivity。

我们同样check我们的方法在12个非均匀分布的数据集上的性能，结果显示在表\ref{tab:4}.在12个测试数据集中，我们的方法分别在10，6和5个数据集上取得了最高的F1 Precision以及Sensitivity。MCluster在三个数据集上取得最好的F1值和sensitivity, 而MetaCluster3.0分别在7个和5个数据集上分别取得最高的precision 和Sensitivity，但是F1值却差强人意。值得注意的是，我们的方法似乎在分布不均匀的数据集上表现更加优异。
\begin{table}[htbp]
\centering
    \caption{Results on 12 unevenly-distributed datasets. Each bold value indicates the best result on a certain dataset.}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{Dataset}} & \multicolumn{3}{|c|}{\textbf{MetaCluster 3.0}}&\multicolumn{3}{|c|}{\textbf{MCluster}}&\multicolumn{3}{|c|}{\textbf{TM-MCluster}}\\
    \cline{2-10}
    &\emph{Pr}&\emph{Se}&\emph{F1}&\emph{Pr}&\emph{Se}&\emph{F1}&\emph{Pr}&\emph{Se}&\emph{F1}\\

  %  \hline
  %  D1&\textbf{.9989}&.9628	&.9805&	.9877&	.9877	&.9877	&.9882	&\textbf{.9882}	&\textbf{.9882}\\
    \hline
    D2&		\textbf{.9997}&	.9648&	.9820&	.9888&	\textbf{.9888}&	\textbf{.9888}&	.9860&	.9860&	.9860\\
    \hline
    D3&		\textbf{.9998}&	.9596&	.9793&	.9950&	\textbf{.9950}&	\textbf{.9950}&	.9948&	.9948&	.9948\\
    \hline
    D4&\textbf{1.0000}	&.9612	&.9802&	.9942&	.9942&	.9942&	.9946&	\textbf{.9946}&	\textbf{.9946}\\
    \hline
    D5		&\textbf{1.0000}&	.9608&	.9800&	.9950&	.9950&	.9950&	.9954&	\textbf{.9954}	&\textbf{.9954}\\
    \hline
    D6	&	\textbf{1.0000}&	.9610&	.9801&	.9966&	\textbf{.9966}&	\textbf{.9966}&	.9966&	\textbf{.9966}	&\textbf{.9966}\\
    \hline
    D7		&\textbf{1.0000}&	.9618&	.9805&	.9980&	.9980&	.9980&	.9988&	\textbf{.9988}&	\textbf{.9988}\\
    \hline
    D9	&.7277&	\textbf{.9628}&	.8289&	.8974&	.8974&	.8974&	\textbf{.9320}&	.9320&	\textbf{.9320}\\
    \hline
    D10	&	.7345&	.9096&	.8127&	.8852&	.8852&	.8852&	\textbf{.9156}	&\textbf{.9156}&	\textbf{.9156}\\
    \hline
    D12		&	.7489&	\textbf{.9066}&	.8202&	.8524&	.8524&	.8524&	\textbf{.8930}&	.8930&	\textbf{.8930}\\
    \hline
    D14&	.7275&	\textbf{.9539}&	.8255&	.8863&	.8860&	.8863&	\textbf{.9420}&	.9420&	\textbf{.9420}\\
    \hline
    D15	&	.7472&	\textbf{.9202}&	.8247&	.8764&	.8764&	.8765&	\textbf{.9070}&	.9070&	\textbf{.9070}\\
    \hline
    D16	&	.6792&	\textbf{.9106}&	.778&	.8546&	.8546&	.8546&	\textbf{.8875}&	.8875&	\textbf{.8875}\\
    \hline
    \end{tabular}
    \label{tab:4}
\end{table}
我们进一步查看我们方法在相对高丰度数据集上的性能。由于AbundanceBin只能处理高丰度数据集，我们将我们的方法与AbundanceBin和MCluster进行比较，结果如表\ref{tab:5}所示。在10个测试数据集上，我们的方法分别在9 6 和8个数据集上取得最高的F1值，Sensitivity以及Precision。MCluster只取得了一个最高的F1值和2个最高的precision，AbundanceBin获得最高的4个Sensitivity。综合来看，在较高丰度数据集上，我们方法性能优于其他方法。
\begin{table}[htbp]
    \centering
    \caption{Results of on high-abundance datasets. Each bold value indicates the best result on a certain dataset.}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{Dataset}} & \multicolumn{3}{|c|}{\textbf{AbundanceBin}}&\multicolumn{3}{|c|}{\textbf{MCluster}}&\multicolumn{3}{|c|}{\textbf{TM-MCluster}}\\
    \cline{2-10}
    &\emph{Pr}&\emph{Se}&\emph{F1}&\emph{Pr}&\emph{Se}&\emph{F1}&\emph{Pr}&\emph{Se}&\emph{F1}\\
    \hline
    S1&.7258	&.9740&	.8317&	.9875	&.9875&	.9875&	\textbf{.9882}&	\textbf{.9882}&	\textbf{.9882}\\
    \hline
    S2&.4047&	.9405&	.5600&	.9154	&.9154&	.9154&	\textbf{.9519}&	\textbf{.9519}&	\textbf{.9519}\\
    \hline
    S3&.5866	&.7528	&.6594&	.8873&	.8873&	.8873&\textbf{	.9361}&\textbf{	.9361}&\textbf{	.9361}\\
    \hline
    S4&.4106	&\textbf{.9441}&	.5723&	.8554&	.8554&	.8554&\textbf{	.8921}&.8921&\textbf{	.8921}\\
    \hline
    S5&.1748	&\textbf{.9871}&	.2970&	.7361&	.7241&	.7301&\textbf{	.7578}&.7546&\textbf{	.7562}\\
    \hline
    S6&.7266&	\textbf{.9999}&	.8416&\textbf{	.9873}&.9873&\textbf{	.9873}&	.9869&	.9869&	.9869\\
    \hline
    S7&.3991&	\textbf{.9999}&	.5705&	.9173&	.9173&	.9173&	\textbf{.9545}&.9545&\textbf{	.9545}\\
    \hline
    S8&.8591&	.8591&	.8591&	.8868&	.8868&	.8868&\textbf{	.9393}&\textbf{	.9393}&\textbf{	.9393}\\
    \hline
    S9&.6457&	.6476&	.6466&	.8581&	.8581&	.8581&\textbf{	.8880}&\textbf{	.8880}&\textbf{	.8880}\\
    \hline
    S10&.1888&	.7223&	.2993&\textbf{	.7253}&	.7161&	.7207&	.7196&	\textbf{.7317}&	\textbf{.7256}\\

    \hline
    \end{tabular}
    \label{tab:5}
\end{table}
现实中，越来越多的元基因组数据都是短序列(大概100bp)，因此我们通过处理短序列数据来评价我们的方法。由于MetaCluster 3.0处理短序列能力有限，我们只列出AbundanceBin MCluster以及我们的方法在数据集A和B(短序列)的性能。结果如表\ref{tab:6}所示和AbundanceBin以及MCluster相比，TM-MCluster 取得了最高的F1 值以及precision，这和我们方法在长序列上的结果是不谋而合的。
\begin{table}[htbp]
    \centering
    \caption{Binning performance of AbundanceBin, MCluster and TM-MCluster on short reads (75bp average) datasets: Dataset-A and Dataset-B. The bold values are the best precision, sensitivity and F1-score.}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{Dataset}} & \multicolumn{3}{|c|}{\textbf{AbundanceBin}}&\multicolumn{3}{|c|}{\textbf{MCluster}}&\multicolumn{3}{|c|}{\textbf{TM-MCluster}}\\
    \cline{2-10}
    &Pr&Se&F1&Pr&Se&F1&Pr&Se&F1    \\
    \hline
    A&.2270&.9878&.3692&	.2250	&\textbf{1.0000}	&.3674&	\textbf{.3165}&.6471&\textbf{.4251}\\
    \hline
    B&.0757&.9878&.1407& .0744	&\textbf{1.0000}&	.1384&\textbf{.1338}&.5836&\textbf{.2177}\\
    \hline
    \end{tabular}
    \label{tab:6}
\end{table}


由于对于大元基因组数据进行聚类耗时费内存，时间和空间效率也是一项重要的评价指标。此处，我们列出AbundanceBin MCluster以及我们的方法在数据集A和B上的时间和空间消耗，结果显示在表\ref{tab:7}中。我们可以看出AbundanceBin花费最少的内存，而MCluster运行最快。由于训练LDA是耗时的，TM-MCluster 花费最多的时间，此外空间消耗也较大。
\begin{table}[htbp]
    \centering
    \caption{Memory and time costs of AbundanceBin, MCluster and TM-MCluster on short reads (75bp average) datasets: Dataset-A and Dataset-B.}
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{Dataset}} & \multicolumn{2}{|c|}{\textbf{AbundanceBin}}&\multicolumn{2}{|c|}{\textbf{MCluster}}&\multicolumn{2}{|c|}{\textbf{TM-MCluster}}\\
    \cline{2-7}
    &Memory&Time&Memory&Time&Memory&Time    \\
    \hline
    A&3.07GB&2.15h&3.20GB&1.36h& 4.12GB&3.11h\\
    \hline
    B&3.20GB&3.20h&3.46GB&2.38h&4.10GB&3.31h\\
    \hline
    \end{tabular}
    \label{tab:7}
\end{table}

最后，我们还比较了TM-MCluster以及MetaCluster 5.0在数据集C D E F G上的性能，结果列在表\ref{tab:8}上。结果表明，TM-MCluster在4个数据集上取得明显高于MetaCluster5.0的Sensitivity，这主要是由于MetaCluster 5.0在聚类时，将低丰度物种的序列都归到小的类里，最后再丢弃。不过，MetaCluster5.0 在五个数据集上都取得较高的precision。由于F-measure是Sensitivity和precision上的权衡，我们的方法依然在4个数据集上取得了较高的F-measure.
此外，MetaCluster 5.0在数据集D差强人意，而这个数据碰巧有最大数量的物种数，并且diverse的丰度比。总而言之，在短序列的高丰度数据集上，
我们的方法取得优于MetaCluster 5.0的性能。
\begin{table}[htbp]
    \centering {
    \caption{Performance comparison: TM-MCluster $vs$. MetaCluster 5.0.}\label{tab:8}
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{Dataset}} & \multicolumn{3}{|c|}{\textbf{MetaCluster 5.0}}&\multicolumn{3}{|c|}{\textbf{TM-MCluster}}\\
    \cline{2-7}
    &\emph{Pr}&\emph{Se}&\emph{F1}&\emph{Pr}&\emph{Se}&\emph{F1}\\
    \hline
    C&\textbf{.9944}	&.3862&	.5563&	.9793	&\textbf{.9793}&	\textbf{.9793}\\
    \hline
    D&\textbf{.9904}&	.4290&	.5986&	.7198	&.\textbf{7198}&	\textbf{.7198}\\
    \hline
    E&\textbf{.9770}	&\textbf{.4806}	&\textbf{.6437}&	.6923&	.4645&	.5574\\
    \hline
    F&\textbf{.9770}	&.3178&	.4796&	.5801&	\textbf{.4645}&	\textbf{.5159}\\
    \hline
    D&\textbf{.8662}	&.0066&	.0131&	.2141&	\textbf{.7988}&	\textbf{.3377}\\
    \hline
    \end{tabular}}
\end{table}



\subsection{真实数据集实验结果}
此外，我们还在真实数据集上测试我们方法的性能。从图\ref{tab:4}上，我们知道R1上的序列属于两个超界，三个属以及五个物种。因此我们预先设定AbundanceBin
MCluster以及我们的方法的聚类个数分别为2，3和5。由于MetaCluster 3.0可以自动决定最终聚类的个数，我们不用为他设定类的个数。对于我们的方法，主题个数设定为100，最终MetaCluster3.0 输出了2个类。上述所有结果都显示在表\ref{tab:9}中。
\begin{table}[htbp]
    \centering
    \caption{Results on the real dataset R1.}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Methods} & \textbf{$\#$~Cluster}  & \textbf{\emph{Pr}} & \textbf{\emph{Se}} &\textbf{\emph{F1}} \\
    \hline
    MetaCluster 3.0   &2 &\textbf{.7328}&.8441&.7845\\

    \hline \multirow{4}{*}{AbundanceBin} & 2 &.3952&\textbf{.9934}&.5655\\
    \cline{2-5}
    %\multirow{4}[3]{2cm}{This is another one} & C4a\\
    & 3 &.3952&\textbf{.9934}&.5655\\
    %\cline{2-5}
    %& 4 &.3932&.9893&.5627\\
    \cline{2-5}
    & 5 &.3952&	\textbf{.9893}&	.5648\\

    \hline \multirow{4}{*}{MCluster} & 2 &.7050&.9422&.8066\\
    \cline{2-5}
    %\multirow{4}[3]{2cm}{This is another one} & C4a\\
    & 3 &.7054&.9179&.7978\\
    %\cline{2-5}
    %& 4 &.6906&.7397&.7143\\
    \cline{2-5}
    & 5 &.6972&.6444&.6698\\

    \hline \multirow{4}{*}{TM-MCluster} & 2 &.7186&.9682&\textbf{.8250}\\
    \cline{2-5}
    %\multirow{4}[3]{2cm}{This is another one} & C4a\\
    & 3 &\textbf{.7211}&.9645&\textbf{.8252}\\
    %\cline{2-5}
    %& 4 &.7793&.8284&.8031\\
    \cline{2-5}
    & 5 &\textbf{.7182}&.9130&\textbf{.8040}\\
    \hline

    \end{tabular}
    \label{tab:9}
\end{table}
尽管MetaCluster 3.0可以自动决定类的个数，他的结果是不准确的，因为R1数据集中有5个物种。对于其他三个方法，AbundanceBin 取得最高的Sensitivity，但是precision是最低的。对于每个预先设定的聚类个数，我们的方法取得最高的F1值。值得一提的是，当预设类个数为数据集实际物种个数5 时，我们的方法取得最高的precision以及F1值，以及仅次于AbundanceBin的Sensitivity。

对于AbundanceBin，MCluster以及我们的方法，当预设的聚类个数从2上升到5时，聚类性能出现下降趋势。这是因为，设定聚类个数分别为2 3 和5 时，会将R1数据集分别往界、属以及类层次聚类。在一个更高层面的，两个类中心的距离一般来说是大于低层次的类中心，因此再较高层次上更容易聚类。



\section{本章小结}
在本节中，我们在模拟数据和真实数据集上，对我们提出的方法进行了全方面的评价，并且与已有的MetaCluster 3.0\5.0、AbundanceBin和MCluster 进行了比较分析，结果显示我们的方法在多数数据集上聚类性能都优于上述方法。





