\chapter{稀疏图上隐私保护可达性查询方法}
\rhead{稀疏图上隐私保护可达性查询方法}


由于对于稀疏图这一种比较特殊的图数据，图中绝大多数的顶点之间不可达，如果我们仍然使用在第4章中提出的\pphop 索引算法，我们需要添加的人工代理中心点将会非常多，致使最后的索引大小较大。在本章中，我们首先介绍一种针对稀疏图的基于最小交集归一化\hop 索引方法，详细介绍它的构建算法并针对该算法进行实验，证明该算法在保证了我们前面定义的隐私保护目标的前提下，相比原始的\hop 的索引大小的变化，以及查询时间的改变。

\section{\muihop 索引算法}

在本节中，我们首先给出\muihop 索引算法的定义：
\begin{Definition}
\label{def:muihop}
    %
    一个图$G=(V(\g)$，$E(\g))$的最小交集归一化\hop $($Minimum Unified Intersection \hop，\muihop $)$就像是定义$~\ref{def:newlabel}$中定义的\hop 索引结构，我们将其表示为$\lin$ 和 $\lout$，并且它具有以下的性质：
    %
    \begin{itemize}
        %
        \item $\forall u, v \in V(G)$,如果$u \leadsto v$，那么$\lin(v) \cap \lout(u)$ $=$ \{$(w, true)$\}, 否则如果$u \not \leadsto v$，那么$\lin(v) \cap \lout(u)$ $=$ \{$(w, false)$\}；
        %
        %
        \item $\sum_{u \in V(G)} (|\lin(u)| + |\lout(u)|)$最小化。
        %
    \end{itemize}
    %
    %
\end{Definition}

从上面定义~\ref{def:muihop}可以看出，在基于\muihop 索引上的可达性查询将是一个简单的集合的交集运算，同时，交集的结果总是只有一个元素。对于给定一个查询$\reach($$u,v$$)$，如果$\lin(v) \cap \lout(u)$ $=$ $(w, true)$表明顶点$u$可以到达顶点$v$，否则如果$\lin(v) \cap \lout(u)$ $=$ $(w, false)$ 表明顶点$u$ 不可以到达顶点$v$。


\begin{figure}[t]
\centering
\includegraphics[height=4cm ,width=10cm]{./example/mui2hop.eps}
\caption{基于图~\ref{fig:graph}中的图数据的\muihop 索引}
\label{fig:mui2hop}
\end{figure}


\begin{Example}
我们在此仍然使用图$~\ref{fig:graph}$中的\hop 基础索引作为我们讨论的例子，基于图$~\ref{fig:graph}$中的\hop 索引，它的一种可能的\muihop 见图$ ~\ref{fig:mui2hop}$，在该\muihop 索引中，$\maxintr$的值为$1$。同时我们在图中使用粗体对真实的中心点标记，对于非粗体的点表示我们算法添加的代理中心点。很明显我们可以看出$\lin$$(4)$$\cap$$\lout$$(0) =$ \{{\bf 0}\}，则表明节点$0$可以到达节点$4$，然而由于$\lin$$(4)$$\cap$$\lout$$(5) = \{12\}$，表示节点$5$不可以到达节点$4$。
\end{Example}

\subsection{\muihop 算法分析}
从定义~\ref{def:muihop}中可以看出，为了构建\muihop 需要两种不同类型的人工代理中心点。(1)使用真实的中心点去覆盖传递闭包集合中的所有可达的点对之间的信息；(2)使用虚假的代理中心点去覆盖那些$u \not\leadsto v$。从上面的叙述中我们可以看出通过添加真实的中心点去覆盖所有的$u \leadsto v$的问题和添加虚假的代理中心点去覆盖$u \not\leadsto v$是相同的问题。所以对于如果构建一个图的\muihop 索引，我们可以将其归纳为一个问题：如何通过添加最少的真实(虚假)中心点使得其可以覆盖所有的$u \leadsto v$($u \not\leadsto v$)，且$|\lin(v) \cap \lout(u)|$~$=$~$1$。

\begin{Lemma}
构建一个图$\g$的\muihop 索引是一个NP-hard问题。
\end{Lemma}

构建\muihop 算法的难度可以通过最小集合覆盖问题(Minimum Set Cover problem, \MSC)转变而来。我们下面证明构建一个图的\muihop 和\MSC 是一个非常相近的问题。考虑图$\g$的所有可达的点对，我们使用一个二分图$B = (V, L, R, E)$，$L(B) = R(B) = V(G)$来表示图$\g$的传递闭包信息$T(\g)$。$L(B)$ 和 $R(B)$ 分别表示$\lin$s和 $\lout$s，对于所有的点$\forall u \in R(B)$, $v \in L(B)$，如果顶点$u$可以到达顶点$v$($ u \leadsto v$)，那么存在$(u, v)\in E(B)$ 。

我们考虑\MSC 的一个实例${\cal U} = E(B)$，其中包含了图$\g$的所有传递闭包信息。我们使用${\cal S}$表示${\cal U}$的一个子集，并且${\cal S}$ $=$ $\{S | S = E(K)$，$K$是二分图$B$的一个同构子图，并且 $\forall u \in R(K), v \in L(K), (u, v) \in E(B)\}$。那也就意味着子图$K$包含了整个 $T(\g)$的所有信息，并且覆盖了所有$E(K)$。进一步，我们需要利用完全二分图来覆盖$E(B)$中的信息，并且确保$E(B)$中的每一条边被覆盖到一次。对于集合${\cal S}$中的每一个$S$($S \in {\cal S}$)，它的权重$weight(S)$ $=$$|L(K)| + |R(K)|$ $=$ $|V(K)|$，因为$E(K)$的信息是由通过向每一个$L(K)$的$\lin$和$R(K)$的$\lout$中添加一个中心点来覆盖的。

\MSC 问题的目标是找到一个集合${\cal S}' \subset {\cal S}$使得：(1)${\cal U}$ 能够被集合 ${\cal S'}$完全覆盖，并且相应的集合$E(B)$中的每一条边都被覆盖。为了得到最小覆盖，集合$E(B)$中的每一条边都仅被覆盖一次，也就意味着如果顶点$u$可以到达顶点$v$($u \leadsto v$)，那么$|\lout(u) \cap \lin(v)|$ $=$ $1$。(2)同时希望$\sum_{S \in {\cal S}'}weight(S)$能够最小化，也就意味着$\sum_{u\in V(G)}(|\lin(u)| + |\lout(u)|)$被最小化。很明显，找到一个这样的集合${\cal S}'$和找到一个最小的\muihop 索引完全一样。由于我们知道\MSC 问题是一个NP-hard问题，所以构建一个\muihop 是一个NP-hard问题。

我们对上面的构建一个图的\muihop 索引问题使用一个传统的\MSC 贪心算法来解决，该贪心算法与最优解之间的近似率为(1+1/2+$\cdots$+$1/|{\cal U}|$)OPT。首先，我们定义一个 ${\cal U}'$ 来表示集合${\cal U}$中未被覆盖的元素，也就是${\cal U}'$ $=$ ${\cal U}$ $=$ $E(B)$。集合${\cal S}$中带有最大的$\frac{|S \cap {\cal U}'|}{w(S)}$值的集合$S$通过不断的迭代从集合${\cal S}$中移除来覆盖${\cal U}'$ ，并从${\cal U}'$ 中将已覆盖到元素移除。当${\cal U}'$ 中所有的元素都已经被覆盖到，那么算法终止。如何找到这样的一个集合$S$等同于从$B$中找到这样一个最大完全二分子图$K$，因为：
\begin{itemize}
    %
    \item [(1)] $\forall u \in R(K), v \in L(K), (u, v) \in E(B)$；
    %
    \item [(2)] $\frac{|S~\cap~~{\cal U}'|}{weight(S)}$ $=$ $\frac{|E(K) \cap
        {\cal U}'|}{|V(K)|}$ $=$ $\frac{|E(K)|}{|V(K)|}$ 是最大化的。
    %
\end{itemize}
其中根据定义$S$ = $E(K)$，我们可以得到$|S \cap {\cal U}'|$ = $|E(K) \cap {\cal U}'|$，$|E(K) \cap {\cal U}'|$ = $|E(K)|$。问题就转化为寻找密集子图问题，由于\MSC 构建问题需要利用到最大完全二分图来覆盖$E(B)$，这就是寻找密集子图问题。已经证明，需要一个二分图的最大完全二分图也是一个NP-hard问题，所以我们的\muihop 索引也是一个NP-hard问题。

\subsection{基于启发式方法的\muihop 构建算法}



在本节中，我们提出一个贪心算法来寻找最大完全二分子图问题，我们将该算法和基于\MSC 的\muihop 的构建算法合并在一起得到我们的基于启发式方法的\muihop 构建算法，见算法~\ref{algo:muis}。算法的输入为一个图数据$\g$，输出为计算出的\muihop 索引($\lin$和$\lout$)。在算法的第1-2行中，我们首先将$\lin$s 和 $\lout$s 设置为空集，同时生成图$\g$的传递闭包集合$T(\g)$以及它的补集$T(\g)^-$。在算法的第3-4行中，分别利用上面计算出的$T(\g)$，$T(\g)^-$得到他们的二分图集合$B$和$B^-$。并且通过调用\AddSurNode\ 程序在生成的$B$($B^-$)基础上对$\lin$和$\lout$中添加真实(虚假)的的中心点，并将其标识位$\flag$设置为true(false)。在第5行中，将生成的$\lin$s 和 $\lout$s返回。

算法~\ref{algo:muis}中的第6-9行\AddSurNode 是\MSC 问题的一个经典贪心算法的二分图描述。对于每一次迭代，如果$E(B)$中的信息还没有被完全覆盖到($E(B) \not= \emptyset$)，则从$B$里面通过\GreedyFndMaxBiK 算法选择一个最大的完全二分图$K$。同时生成一个新的中心点，并根据其$\flag$设置相应的标志信息，然后根据$(u,v) \in E(K)$的信息，将该中心点加入到$\lin(v)$和$\lout(u)$中。在第9行中，将已经被覆盖到的$E(K)$从$E(B)$中移除。

算法~\ref{algo:muis}中的第10-14行，\GreedyFndMaxBiK 算法用来寻找$B$的一个最大完全二分子图$K$。\GreedyFndMaxBiK 算法首先初始化一个空的图$K$。然后算法如果能够找到一个点的集合$T$，使得对于$T$中的每一个点$u \in T$，可以和$K$中的点构成一个完全二分子图。 在算法的第12行中，从$T$中选择一个具有最大的度的点作为候选点$u_{\max}$，并将$u_{\max}$加入到$K$中，使其构成为一个更大的完全二分图。算法\GreedyFndMaxBiK 在再也找不到这样一个集合$T$时结束，并将当前的最大完全二分图$K$返回。这样返回的$K$是当前最大的一个完全二分图。使用\GreedyFndMaxBiK 的一个好处在于它的效率是最接近最优的：从$B$中寻找一个最大完全二分子图等同于从$B^-$ 中寻找一个最大独立子集$M$，其中$B^-$是$B$的一个补图。众所周知，这样的一个贪心算法，找出的最大独立子集的近似度在$1/(1+\Delta)$。


\begin{algorithm}
 \caption{\muis\ ($\g$)}
\label{algo:muis} {
 \begin{algorithmic}[1]
 \Statex {\bf Input:} 一个图数据$\g =(V(\g),E(\g))$
 \Statex {\bf Output:} 图$\g$的\muihop\:$\lin$ 和 $\lout$

 \State 对于图中所有的顶点$\forall u \in V(G)$，$\lin(u) = \lout(u) = \emptyset$
 \State 生成图$\g$的$T(\g)$ 和 $T(\g)^-$
 \State 生成$T(\g)$的$B$，并调用子程序\AddSurNode\ ($B$, $\lin$, $\lout$, $true$)
 \State 生成$T(\g)^-$的$B^-$，并调用子程序\AddSurNode\ ($B^-$,$\lin$,$\lout$,$false$)
 \State {\bf return } $\lin$ 和 $\lout$
 \Statex

 \Statex {\bf Procedure~\ref{algo:muis}.1} \AddSurNode\ ($B$, $\lin$, $\lout$, $\flag$)
 \State {\bf while} $E(B) \not= \emptyset$ \quad \quad //边还没有被覆盖完
 \State \quad $K$ $\leftarrow$ \GreedyFndMaxBiK\ ($B$)
 \State \quad $\forall (u,v) \in E(K)$, 加入一个新的点 $w$到$\lin(v)$和$lout(u)$中
 \Statex \quad \quad $\lin(v) \leftarrow \lin(v) \cup \{(w, \flag)\}$，
 \Statex \quad \quad $\lout(u) \leftarrow \lout(u) \cup \{(w, \flag)\}$
 \State \quad $E(B) \leftarrow E(B)/E(K)$ \quad \quad 从$B$中移除$K$中的边
 \Statex

 \Statex {\bf Procedure~\ref{algo:muis}.2} \GreedyFndMaxBiK\ ($B$)
 \State 初始化一个空的最大完全二分图$K$
 \State {\bf while }$T \not= \emptyset$，$T$=$\{ u | \{u\}$$\cup$$V(K)$ 在 $B$中构成一个最大完全二分图$\}$
 \State \quad 设置$u_{\max} = \arg\max_{u \in T}(Deg(u))$
 \State \quad $V(K) \leftarrow V(K) \cup \{u_{\max}\}$
 \State {\bf return } $K$


  \end{algorithmic} }
\end{algorithm}

\section{基于\muihop 的隐私保护可达性查询算法}
\label{sec:pp2hopquery}


在本节中，我们定义了\muihop 的加密算法以及如何基于加密的\muihop 进行可达性查询的处理，最后我们对我们的隐私保护的可达性查询算法进行分析。

\begin{Definition}\label{def:ppmuihop}
    %
    一个图$\g$的隐私保护\muihop $(\ppmuihop)$就是图$\g$的 \muihop 索引方法的一个加密的索引，我们将其表示为$\line$ 和 $\loute$，对于\muihop 中的每一个中心点$($w$, $\flag  $)$，我们通过加密算法将其变换为$($$h_{s_1}(w)$, $\enc(\flag)$$)$，其中$h_{s_1}$是一个单向哈希函数，$\enc$是一个随机加密算法。
    %
\end{Definition}

{\bf 隐私保护的可达性查询。}基于以上的\ppmuihop 索引，可达性查询算法可以分为以下三个步骤：(1)客户端将$\reach$$(u, v$$)$可达性查询通过哈希方法，使其转化为$\reach^e$$(u_e, v_e$$)$，其中$u_e = h_{s_2}(u)$， $v_e = h_{s_2}(v)$，并同时将哈希后的可达性查询提交至服务端\SP。(2)服务端\SP 检索出$\line(v_e)$和$\loute(u_e)$并进行交集运算$\line(v_e) \cap \loute(u_e)$，交集的结果会得到一个加密的二元组($w_e$, $\flag_e$)，\SP 从二元组中提取出$\flag_e$，然后将该$\flag_e$返回给查询的客户端；(3) 客户端通过使用从数据拥有者获得的授权密钥对$\flag_e$进行解密，得到最终的查询结果，如果解密结果为$true$，则说明$ u \leadsto v$，否则说明$u \not\leadsto v$。


{\bf \ppmuihop 隐私保护分析。} 我们接下来，对本章中针对稀疏图数据提出的\ppmuihop 安全性进行分析，我们可以证明，我们的索引和查询方法在~\ref{sec:def}节中定义的攻击模型情况下是完全安全的。

\begin{Lemma}
\label{prop:muipphop1}
\ppmuihop 索引及其查询算法可以有效的保护查询顶点之间的可达性信息$\reach^e(u_e, v_e)$。
\end{Lemma}

首先对于($w_e$, $\flag_e$) $\in$ $\line(u)$ (或者 $\loute(u)$)，攻击者\SP 无法推测一个中心点$w_e$是否为真实的中心点或者是一个虚假的中心点。其主要原因在于：(1)对于图中的顶点$u \in V(\g)$和所有\ppmuihop 索引中的中心点$w$，我们是通过使用带有不同参数的哈希方法进行哈希，进而\SP 无法确定这两类顶点之间的关系，也就无法确定一个点是否为原图数据中的一个顶点。(2)$\flag_e$是通过使用$\enc$进行了加密，通常情况下我们可以使用AES加密算法对其进行加密，由于AES加密算法，\SP 无法对其进行破解，所以\SP 无法获取到$\flag_e$对应的原文信息。综上两点所述，攻击者既无法破解中心点的哈希算法也无法破解标志位的AES加密算法，所以它无法获取查询结果的任何信息。

基于上面的分析，同时，对于一个给定的查询$\reach^e$$(u_e,v_e$$)$，攻击者\SP 无法对$\line(v_e)$和 $\loute(u_e)$进行破解，由于对于任何的查询$\line(v_e) \cap \loute(u_e)|$的结果始终为只包含有一个二元组，它的大小始终为1。同时由于($w_e$, $\flag_e$)是被进行了加密，所以在查询处理期间，攻击者\SP 不能获取到查询的任何信息。所以查询的节点之间的可达性信息得到了保护。

\begin{Lemma}
\label{prop:muipphop2}
\ppmuihop 索引及其查询算法可以有效的保护原始图数据的结构信息。
\end{Lemma}

我们可以使用反证法来证明引理~\ref{prop:muipphop2}的正确性。我们假设攻击者\SP 可以推测出图中的一条边$(u,v)$的存在性，那么攻击者\SP 必然可以破解至少一个查询$\reach^e$$(u_e, v_e$$)$，这个和引理~\ref{prop:muipphop1}中\SP 不能破解任何\ppmuihop 索引相违背，所以 \ppmuihop 索引及其查询算法可以有效的保护原始图数据的结构信息。


\section{实验结果}
在本节中，我们通过实验对\ppmuihop 中算法的效果进行实验室验证。

\begin{table}[t]
%\vspace{-6ex}

%\begin{minipage}{0.5\linewidth}
\centering
\caption{真实数据和合成数据集信息}

\begin{tabular}{|c|c|c|c|c|c|}
\hline
$\g$ & $|V(\g)|$  & $|E(\g)|$ & $|V(\g)|/|E(\g)|$ & $|V$(\DAG$(\g)$)$|$ &  $|E$(\DAG$(\g)|$) \\
\hline
\SYN-1 & 3,073 & 37,615 & 0.08 & 3,073 & 37,615 \\
\hline
\SYN-2 & 5,651 & 15,968 & 0.35 & 5,651 & 15,968 \\
\hline
\SYN-3 & 4,880 & 27,946 & 0.17 & 4,880 & 27,946 \\
\hline
real-1 & 6,927 & 11,850 & 0.58 & 6,927 & 11,850 \\
\hline
real-2 & 34,546 & 421,578 & 0.08 & 21,608 & 281,030  \\
\hline
real-3 & 62,586 & 147,892 & 0.42 & 48,438 & 96,976\\
\hline
real-4 & 75,879 & 508,837 & 0.15 & 42,176 & 61,995\\
\hline
real-5& 82,140 & 549,202 & 0.15 & 53,599 & 200,101\\
\hline
real-6 & 82,168 & 948,464 & 0.09 & 10,559 & 28,331 \\
\hline
real-7 & 81,306 & 2,420,766 & 0.03 & 12,248 & 95,659\\
\hline
\end{tabular}
\label{table:dataset}
%\end{minipage}
\end{table}




\begin{table}[t]
%\begin{minipage}{0.5\linewidth}
\centering
\caption{\ppmuihop 实验结果}
\begin{tabular}{|c|c|c|c|c|}
\hline
$\g$ & $|$\muihop$|$ & $|T$(\DAG$(\g)$$)|$ & $|V$(\DAG$(\g)$)$|^2$ & Constr. time \\
\hline
\SYN-1 & 2.11M & 2.91M & 9.44M & 11s \\
\hline
\SYN-2 & 7.30M & 0.29M & 31.93M & 1min25s \\
\hline
\SYN-3 & 9.24M & 2.44M & 23.81M & 1min35s \\
\hline
real-1 & 1.49M  & 400K & 47.98M & 22s \\
\hline
real-2 & 19.13M & 84.25M & 466.90M & 16min43s\\
\hline
real-3 & 11.34M & 18.17M & 2.35G & 28min51s\\
\hline
real-4 & 12.02M & 348.83M & 1.78G & 28min20s\\
\hline
real-5 & 20.33M & 371.90M & 2.87G & 52min38s\\
\hline
real-6 & 434.15K & 21.18K & 111.49M & 18s \\
\hline
real-7 & 606.77K & 37.78K & 150.01M & 32s \\
\hline
\end{tabular}
\label{table:muihop}
%\end{minipage}

\end{table}


\paragraph{实验设置}
我们在一台普通的PC上进行我们的实验，这台机器配置有一颗3.40GHz的CPU和16GB内存。我们使用7个真实数据集和3个合成数据集来验证我们算法的有效性。7个真实的数据集其中的real-1(ERDOS)来自于\cite{erdos}，real-2 (Cit-HepPh), real-3
(p2p-Gnutella31), real-4 (soc-Epinions1), real-5 (soc-sign-Slashdot090221), real-6
(soc-Slashdot0922)和real-7 (ego-Twitter)实验数据集来自于\cite{communication_networks}。关于这些实验数据集的一些特性信息见表~\ref{table:dataset}。对于每一个图，我们首先将其转化为一个有向无环图(DAG)后，再对其建立\ppmuihop 索引。

\paragraph{\ppmuihop 的效果比较}
在表~\ref{table:muihop}中，我们列出了\ppmuihop 索引的效果数据信息。我们从结果中可以看出，$T(\g)$中真实的中心点的数量约为$|V(\g)|^2$的9\%左右，所以\ppmuihop 索引的大小都几乎是$|V(G)|^2$级别的1/11左右，大小相比于之前\pphop 有了进一步的改善。同时，我们可以看到，针对真实数据集，\ppmuihop 的索引大小要比$|V(G)|^2$ 的4\%左右，在真实的数据集上，我们的算法的效果更加优秀。\ppmuihop 索引的创建时间，最大的在53分钟，这个时间相比图的大小来说也是一个能够接受的范围，但是如果我们使用\cite{chengjf1}的算法，该创建时间会大大缩短。

\paragraph{查询效果}
我们从这些图中随机选择1000个查询点对。对于所有的查询，其服务端\SP 的查询时间都非常的快，对于合成数据集该查询时间在1.4s左右，对于真实数据集，该查询时间最大在0.18s，这些时间对于一个查询，都是一个可以接受的时间范围。

\section{本章小结}
在本节中，我们针对稀疏图数据提出了一种特殊的\hop 索引来提供一个可以实现隐私保护的可达性查询索引结构和查询算法。在本节中，我们提出了一种基于最小顶点覆盖的启发式构建\ppmuihop 算法，我们通过实验表明，\ppmuihop 索引对于真实数据集和合成数据集都具有非常好的效果，同时，在本章中，我们也同样对我们提出的\ppmuihop 索引方法进行了隐私保护的证明，证明我们的索引结构可以实现可达性查询时的隐私保护功能。





