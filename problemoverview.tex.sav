\chapter{问题定义与系统概述}
\rhead{问题定义与系统概述}

在本章中，我们将介绍本文研究的背景知识、问题的定义以及我们解决方案的一个概述。在本文中常用的符号见表~\ref{table:symbol}

\begin{table}[t]\label{table:symbol}
    \caption{ 文中常用符号 }
    \label{table:symbol}
    \setlength{\tabcolsep}{1pt}
    \centering
    \begin{tabular}{p{4cm}|p{10cm}}
        \hline
        {\bf  符号} & {\bf 描述} \\
        \hline
        $u \leadsto v$ & 一个可达性查询，查询$u$是否可以到达$v$ \\
        \hline
        $\lout(u)$, $\lin(u)$ & 顶点$u$的\hop\ 索引 \\
        \hline
        $\maxintr$ & $\maxintr = \forall u, v, max(|\lout(u) \cap \lin(v)|)$ \\
        \hline
        $\louts(u)$, $\lins(u)$ & 顶点$u$添加了人工点之后的\hop\ 索引  \\
        \hline
        $\loutmax$ ($\linmax$) &  $\louts$ ($\lins$) 中最大的集合的大小 \\
        \hline
        $\hash_{s}(\cdot)$ & 带有参数 $s$ 的hash函数\\
        \hline
        $\encrypt(\cdot)$, $K$ & Elgamal加密算法, 解密的密钥$K$ \\
        \hline
        $u_e \leadsto v_e$ & 一个加密的可达性查询  $u_e = \hash_{s_2}(u)$, $v_e =
        \hash_{s_2}(v)$ \\
        \hline
        $\loute(u)$, $\line(u)$ & 顶点$u$的加密的\pphop \\
        \hline
        $\we$ & 加密的中心点$w$, $\we = \hash_{s_1}(w)$  \\
        \hline
        $\fe$ & 加密的标志位标志$f$, $\fe = \encrypt(f)$ \\
        \hline
        $R$ & $\line(u_e) \cap \loute(v_e)$的交集结果 \\
        \hline
        $\re$ & 服务端返回的加密了的可达性查询结果 \\
        \hline
    \end{tabular}
\end{table}

\section{\hop 索引方法概述}

在本文中，我们考虑的是基于有向无环图的可达性查询。我们通常用$\g$来表示一个图数据，$V(\g)$ 和 $E(\g)$分别表示图的顶点集合和边的集合。由于在一个强连通分量里的各个点的可达性信息是完全一样的，所以在本文中，为了描述的方便性，我们假设所有的图为有向无环图(Directed Acyclic Graph)。对于图上的每一个点$u \in V(\g)$ 都具有两个顶点集合$\lout(u)$和$\lin(u)$，我们把这两个集合称之为顶点$u$的\hop 索引。对于$\lout(u)$集合中的点，表示可以从顶点$u$到达的点。对于$\lin(u)$集合中的点，表示这些点可以到达顶点$u$。这些$\lin(u)$和$\lout(u)$集合中的点，我们也称之为中心点。对于给定两个点$u$和$v$，我们称顶点$u$可以到达$v$当且仅当$\lout(u) \cap \lin(v) \neq \emptyset$，可以记为$u \leadsto v$。为了保证图的顶点集合$\g$的\hop 索引信息能够包含图$\g$上顶点间所有的可达性信息，所以\hop 索引里的I型奶昔必须包含图$\g$传递闭包集合$T(\g)$里面的所有元素。很明显，我们可以有很多种算法来计算图$\g$的\hop 索引。之前的大部分工作都希望建立出来的\hop 索引大小能够最小，索引的大小我们可以定义为$\sum_{u \in V(\g)}(|\lout(u)| + |\lin(u)|)$。


\hop 的索引创建通常被认为似乎非常耗时和对系统要求很高的。尽管已经有很多工作(例如\cite{chengjf2})明显的优化了原始的\hop 的创建时间，但是实际上，\hop 的创建基本上都是离线建立的。由于生物信息网络、通信网络等等数据更新不是非常的频繁，所以这些数据的拥有者可以先在本地建立好相应图数据的\hop 索引，然后再将处理完的\hop 索引上传到服务商\SP ，使得可以支持高并发的可达性查询请求。

我们在这里先简要介绍一下\cite{cohen}文中建立\hop 的算法流程，我们在后面将针对我们的问题，提出针对这种原始的算法的改进算法。%这里可以加一个2hop的算法
首先，我们用一个变量$T'$表示图$\g$的传递闭包$T(\g)$所有没有被覆盖到的元素，也即$T' = T(\g)$。通过不断的迭代，使得$T(\g)$中的元素不断的被覆盖并从$T'$中移除。当集合$T'$中的元素变为空时，以上的迭代结束。对于同种的每一个点$w \in\g$，都对其建立一个相应的二分无向图(也可称为中心图)$\g_w(\l_w, \r_w,\e_w)$，这里的$\l_w$是指所有的可以到到点$w$的点的集合，$\r_w$是所有点$w$可以到的点的集合。$(u, v) \in \e_w$ 当且仅当 $(u ,v)$ 在集合$T'$中。然后启发式算法每次选择一个中心点$w$，该中心点具有它对应的二分图$\g_w$中最大的$\maxDC$比例的子图$\g_i(\l_i,\r_i, \e_i)$ of $\g_w$。具体的$\maxDC$定义为：
\begin{equation}\label{equ:2hop}
\maxDC = \frac{|\e_i \cap T'|}{|\l_i \cup \r_i|}
\end{equation}

这个问题实际上就变为查找图$\g_w$的最大稠密子图。在每一次的循环中，具有最大的$\maxDC$的点$w$被选为一个中心点。对于所有的$ u \in \l_i$ 和 $v \in \r_i$，算法将中心点$w$加入到$\lout(u)$和$\lin(v)$中，并从$T'$中移除$(u, w)$,$(w, v)$和$(u, v)$。


\begin{figure}
\centering
\includegraphics{example/graph.eps}
%\vspace{-2ex}
\caption{图以及它的2-hop索引}
\label{fig:graph}
\end{figure}



我们考虑图~\ref{fig:graph}中左边的这样一个代表生物网络的简单有向无环图。图中，顶点的标号表示一些化学物质的编号，图中的边表示两种物质之间的一种化学反应。图中，所有的顶点的标签为了叙述的简洁性，我们在此略去。左图所对应的原始的\hop 索引文件见图~\ref{fig:graph}右边表格。我们考虑查询顶点1可不可以到达顶点5，也即$1 \leadsto 5$，我们可以看到$\lout(1) \cap \lin(5) =\{5\}$，所以我们可以得到顶点1可以到达顶点5。然而对于顶点6到顶点0，由于$\lout(6) \cap\lin(0)=\emptyset$，所以我们说顶点6无法到达顶点0。在这里我们用一个简单的例子说明了\hop 索引是如何建立同时如何利用建立的\hop 索引进行可达性的查询。


\section{密码学简介}

我们在第一章中介绍到，我们需要在加密的\hop 索引文件上进行可达性查询的处理。在本篇文章中，我们主要利用到以下两个密码学中的技术。

哈希函数就是把任意长度的输入，通过内部的散列算法，变换成固定长度的输出，这个输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一确定输入值。简单来说哈希函数是一种将任意长度的消息压缩到某一固定长度的消息摘要函数。通常一个哈希函数记为$hash()$。对不一个给定的数据值$m$，它的哈希值记为$hash(m)$。哈希函数具有以下两个特性：(1)单向性，也即对于一个给定的哈希值$hash(m)$，我们很难从这个哈希值推算出它原来的值。(2)抗冲突性，即通常对于不同的输入所产生的哈希值是一一对应的，很难找到两个不同的输入使得他们的哈希值一样。目前一种比较成熟和安全的哈希函数是SHA-1 \cite{sha}。

在密码学领域中，通常在哈希函数中通过引入一个参数，称之为盐，来提高哈希函数的随机性。通常带有一个参数的哈希函数记为$\hash_s()$。通过给定不同的盐参数，那么同样的哈希函数在相同的原始输入下所产生的输出是不同的。总结来说，如果$s_1 \neq s_2$，那么$\hash_{s_1}(m) \neq \hash_{s_2}(m)$，反之如果$s_1 = s_2$，则$\hash_{s_1}(m) = \hash_{s_2}(m)$。在本文中，我们使用了两个不同的盐参数来作为数据拥有着的私有密钥的一部分。

所谓乘法同态加密算法是指在它密文上进行的算法操作与在它明文上的乘法操作是同态的。一个乘法同态加密算法通常记为$\encrypt(\cdot)$，对于乘法同态的定义具体来说，给定两个密文$\encrypt(m_1)$和$\encrypt(m_2)$，